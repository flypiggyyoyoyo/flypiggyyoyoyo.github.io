<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL笔记</title>
      <link href="/2025/05/14/SQL%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/05/14/SQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习SQL写法的笔记</p></blockquote><hr><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><p>数据分散到多个表时，需要用表连接来关联数据</p><p><strong>结构</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 表<span class="number">1.</span>字段, 表<span class="number">2.</span>字段</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line">[连接类型] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>共同字段 <span class="operator">=</span> 表<span class="number">2.</span>共同字段;</span><br></pre></td></tr></table></figure><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><em>只返回两表之中满足条件的记录（<strong>交集</strong>）</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id; <span class="comment">-- 可简写为 JOIN</span></span><br></pre></td></tr></table></figure><h2 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h2><p><em>返回左表（表 A）的 所有记录，右表（表 B）中匹配的记录，若右表无匹配则用 NULL 填充</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id;</span><br></pre></td></tr></table></figure><h2 id="右链接"><a href="#右链接" class="headerlink" title="右链接"></a>右链接</h2><p><em>返回右表（表 B）的 所有记录，左表（表 A）中匹配的记录，若左表无匹配则用 NULL 填充</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id;</span><br></pre></td></tr></table></figure><h2 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h2><p><em>返回两表的 所有记录，匹配的记录合并，不匹配的字段用 NULL 填充（并集）</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id;</span><br></pre></td></tr></table></figure><p>MySQl不支持上面的写法，下面是替代方案</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 条件</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 条件</span><br><span class="line"><span class="keyword">WHERE</span> 表A.id <span class="keyword">IS</span> <span class="keyword">NULL</span>; <span class="comment">-- 去重左连接已包含的记录</span></span><br></pre></td></tr></table></figure><h2 id="多表联查"><a href="#多表联查" class="headerlink" title="多表联查"></a>多表联查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.a_id</span><br><span class="line"><span class="keyword">JOIN</span> 表C <span class="keyword">ON</span> 表B.id <span class="operator">=</span> 表C.b_id;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记(3)：事务隔离</title>
      <link href="/2025/05/12/MySQL%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
      <url>/2025/05/12/MySQL%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第三讲：事务隔离"><a href="#第三讲：事务隔离" class="headerlink" title="第三讲：事务隔离"></a>第三讲：事务隔离</h1><h2 id="多事务同时执行的问题"><a href="#多事务同时执行的问题" class="headerlink" title="多事务同时执行的问题"></a>多事务同时执行的问题</h2><ul><li>脏读：某个事务读取到了修改完未提交的数据</li><li>不可重复读：同一事务，两次读取某行数据，结果不一致（针对<strong>单行数据</strong>）</li><li>幻读：同一事物，两次相同的查询，结果集不一样（符合条件的记录被<strong>新增</strong>或<strong>删除</strong></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><ul><li>一个事务还未提交时，它做的更改就可以被看见</li><li>自动实现</li><li>会出现“三读”问题</li></ul><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><ul><li>一个事务提交后，它做的更改才可被看见</li><li>mvcc实现</li><li>会出现不可重复读、幻读问题</li></ul><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><ul><li>一个事务从启动到结束，看到的数据始终一致</li><li>mvcc实现</li><li>按照SQL标准，可重复读的隔离级别仅能保证“事务内多次读取同一行数据，数据内容一致”（解决不可重复读），不能保证“结果集的行数一致”（幻读）</li><li>innoDB通过mvcc+间隙锁解决不可重复读和幻读问题</li></ul><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><ul><li>对每一行数据，读操作加读锁，写操作加写锁，当读写锁冲突时，后访问的事务必须等待前一个事务结束才能继续执行</li><li>加锁实现</li><li>不出问题</li></ul><h2 id="隔离的实现——MVCC"><a href="#隔离的实现——MVCC" class="headerlink" title="隔离的实现——MVCC"></a>隔离的实现——MVCC</h2><ul><li>多版本并发控制</li><li>通过为数据行维护多个版本，让读操作可以不加锁的访问历史数据，避免读写冲突</li></ul><h3 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h3><p><strong>核心思路：留存数据的历史记录</strong></p><p>假设有一张学生成绩表，某行数据为<code>张三，数学，90分</code>  </p><p>当数据被修改时，比如改到85分，<strong>不直接覆盖数据</strong>，而是：  </p><ul><li>把旧数据存在“历史版本”（undolog）</li><li>新数据写在当前版本，并记录“谁改的”（事务id），这样数据有了多个版本：旧版本（90分，事务1改的）、新版本（85，事务二改的）</li></ul><p><strong>读数据时：根据 “时间线” 决定看哪个版本</strong></p><p>每个事务启动时，就像拿到一个 “时间戳”（事务 ID，比如 100、200、300，递增的）</p><p>读数据时，数据库会生成一个 “快照”（Read View），记录两件事：</p><ul><li>当前有哪些事务还没提交（比如事务 200、300 在运行中）</li><li>我自己的事务 ID 是多少（比如 100）</li></ul><p><strong>然后按规则判断：</strong></p><ul><li>如果旧版本的事务 ID 比我早（比如 100 之前的 99），说明这个版本在我启动前就提交了，我能看到它（旧数据有效）</li><li>如果新版本的事务 ID 比我晚（比如 200、300），说明这个版本是我启动后才改的，而且对应的事务还没提交，我看不到它（只能看到旧数据）</li><li>如果新版本的事务 ID 和我同时存在（比如我是 100，它是 150 但没提交），它还没写完，我也看不到，只能看旧数据。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MVCC通过“多版本数据+读视图”实现无锁读技术，核心是让读操作访问历史版本而非实时数据，从而在保证事务隔离性的同时提升并发能力</p>]]></content>
      
      
      <categories>
          
          <category> MySQL45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记(2)：一条SQL更新的执行</title>
      <link href="/2025/05/07/MySQL%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
      <url>/2025/05/07/MySQL%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第二讲：一条SQL更新语句是如何执行的"><a href="#第二讲：一条SQL更新语句是如何执行的" class="headerlink" title="第二讲：一条SQL更新语句是如何执行的"></a>第二讲：一条SQL更新语句是如何执行的</h1><blockquote><p>查询语句需要走的流程，更新语句也同样需要，比如连接器验证链接身份、解析器解析词法语法等，唯一不同在于执行器执行的时候，特殊的<strong>更新操作</strong>。而这个操作又涉及到两个日志：redolog（重做）和binlog（归档）</p></blockquote><h2 id="如果更新操作不借助日志？"><a href="#如果更新操作不借助日志？" class="headerlink" title="如果更新操作不借助日志？"></a>如果更新操作不借助日志？</h2><ul><li>方案一：每次更新直接写入磁盘，这样每次更新都对应一次磁盘io，成本过高</li><li>方案二：每次修改把脏页暂存在内存里，然后延迟异步刷盘（保证性能）。但如果系统突然崩溃，内存中的脏页会丢失，此时无法保证事务的持久性</li></ul><p><em>脏页：内存中已经被修改但还没被刷新到磁盘上的数据库页面</em></p><p>显然，这两种方法都是有缺陷的，既要保证性能，又要保证持久性，就引入了<strong>WAL</strong>技术，也就是<strong>Write-Ahead Logging</strong>，关键点是先写日志，再写磁盘，这个日志就是<strong>redolog</strong></p><h2 id="RedoLog日志"><a href="#RedoLog日志" class="headerlink" title="RedoLog日志"></a>RedoLog日志</h2><ul><li>InnoDB引入的一块磁盘区域，在事务提交时，把日志写入这块磁盘区域，记录下对数据页的物理修改</li><li>这样一来，即使数据库发生异常重启，也可以凭借RedoLog来找回脏页数据，这个能力叫<strong>crash-safe</strong></li><li>RedoLog是固定大小的文件，以循环的方式写入，不断覆盖最早的内容</li></ul><h2 id="binlog日志"><a href="#binlog日志" class="headerlink" title="binlog日志"></a>binlog日志</h2><p>MySQL整体来看有两块，Server层用来实现MySQL大部分功能，存储引擎层用来存储数据。RedoLog是InnoDB引擎独有的日志。Server层也有自己的日志，叫binlog（归档日志）</p><ul><li>binlog是记录所有<strong>数据库表结构变更</strong>和<strong>表数据修改</strong>的二进制日志</li><li>由Server层实现，所有引擎都可以使用</li><li>binlog是可以追加写入的，当binlog文件写到一定大小后会切换下一个，并不会覆盖以前的日志</li></ul><h3 id="执行update语句的内部流程"><a href="#执行update语句的内部流程" class="headerlink" title="执行update语句的内部流程"></a>执行update语句的内部流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ul><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>指的是把redolog的写入分成了两个步骤，prepare和commit，这就是两阶段提交。</p><p><strong>记住，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</strong></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>定期全量备份的周期，在什么场景下，一天一备会比一周一备更有优势？</p><ul><li>数据更新频繁的系统，如电商、银行</li><li>数据一致性要求高的系统，如证券交易系统</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记(1)：一条SQL查询的执行</title>
      <link href="/2025/05/06/MySQL%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
      <url>/2025/05/06/MySQL%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第一讲：一条SQL查询语句是如何执行的"><a href="#第一讲：一条SQL查询语句是如何执行的" class="headerlink" title="第一讲：一条SQL查询语句是如何执行的"></a>第一讲：一条SQL查询语句是如何执行的</h1><h2 id="MySQL架构理解"><a href="#MySQL架构理解" class="headerlink" title="MySQL架构理解"></a>MySQL架构理解</h2><p>首先我们知道，MySQL是分为Server层和存储引擎层两部分的。   </p><p>Server层里有连接器、查询缓存（MySQL8.0后被删除）、分析器、优化器、执行器等，负责构建MySQL的大部分功能；</p><p>存储引擎层采用插件式架构，可以支持不同的存储引擎，负责存储数据。通俗来讲，存储引擎层就像一个包裹，负责把存储引擎打包到一起，并向Server层提供读写接口</p><p>注意，不同的存储引擎<strong>共用一个</strong>Server层。也就是说，MySQL架构中，有一个Server层，一个存储引擎层，所有存储引擎公用一个Server层</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接命令一般这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure><p>mysql是客户端工具，用来链接服务端。当完成TCP三次握手后，开始验证用户身份，用的是输入的<strong>用户名</strong>和<strong>密码</strong></p><ul><li>若用户名或者密码错误，则报错<code>Access denied for user</code>，然后结束</li><li>若正确，则连接器会去权限表中查找用户拥有的权限。<strong>此后</strong>，这个链接中权限的判断逻辑，都<strong>依赖此时读到的权限</strong></li></ul><p>一个用户建立连接后，即时用管理员用户对这个用户权限做修改，也不会影响现存的链接，在建立新的链接才会使用新的权限设置</p><p>一个链接长时间不用会自动断开，需要重连才能执行请求。建议使用长连接，并定期断开再重连、执行 mysql_reset_connection 来重新初始化连接资源</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立之后，MySQL拿到查询请求，首先会去查询缓存看看，之前是否有执行过这条语句。之前执行过的语句+结果会以键值对形式存入内存。如果能命中key，则value会被直接返回</p><p>对更新压力大的数据库来说命中率极低，因为只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p><strong>MySQL8.0版本开始直接删掉这块功能了</strong></p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>未命中或没用查询缓存，则分析器发力了</p><p>先做<strong>词法分析</strong>，根据输入的SQL语句，识别出里面字符串是什么。把输入的“select”识别出这是一个查询语句，把输入的“ID”识别成“列ID”</p><p>根据词法分析的结果和语法规则，进行<strong>语法分析</strong>，分析输入的语句是否合法</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过分析器，MySQL知道你要做什么。再用优化器选择方案—怎么做</p><p>优化器是决定再多个索引的时候使用哪个索引，在多表关联的时候决定各个表的关联顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li><p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</p></li><li><p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</p></li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL通过分析器知道做什么，通过优化器知道怎么做，现在进入执行阶段</p><p>执行之前会先判断用户对这个表有没有执行权限</p><p>执行流程对比：</p><p>无索引情况，则全表扫描，具体流程如下：</p><ul><li>调用存储引擎接口获取表的第一行数据</li><li>检查该行数据是否满足查询条件（例如 ID = 10），如果满足则将其加入结果集；若不满足则跳过该行</li><li>继续调用存储引擎接口获取下一行数据，重复步骤 2，直到遍历完表中的所有行</li><li>最后将满足条件的所有行组成结果集返回给客户端</li></ul><p>有索引情况，利用索引来快速定位满足条件的数据，具体流程如下：</p><ul><li>通过索引结构快速定位到满足查询条件的第一行数据的位置</li><li>调用存储引擎接口获取该行数据并加入结果集</li><li>利用索引继续查找满足条件的下一行数据，重复步骤 2，直到没有满足条件的行</li><li>将满足条件的所有行组成结果集返回给客户端</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p><p>解析器阶段，解析词法的时候，没找到</p>]]></content>
      
      
      <categories>
          
          <category> MySQL45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker（一）理论知识</title>
      <link href="/2025/04/09/Docker%EF%BC%88%E4%B8%80%EF%BC%89%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/04/09/Docker%EF%BC%88%E4%B8%80%EF%BC%89%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直在用docker，没系统的捋一遍。这准备简历，所以重新弄一遍，本篇只涵盖使用的知识。后面会有实战部署笔记和底层技术。</p><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>流程：研发镜像（image）-&gt;上传到镜像仓库（Registry）-&gt;通过Docker引擎down下来-&gt;运行down下来的容器（container）</p><ul><li><p>Docker是一个容器引擎，用于管理容器的声明周期</p></li><li><p>容器：包含用于运行一个软件的环境（包含了目标软件运行所需的所有依赖）和需要运行的软件，镜像的实例</p></li><li><p>镜像：容器的安装包，必须先有镜像，才能运行容器</p></li><li><p>仓库：用于存放镜像，对镜像进行统一管理</p></li></ul><p>打个比方：仓库是软件商店，镜像是软件安装包，容器是安装成功后的软件</p><h3 id="Docker与虚拟机对比理解"><a href="#Docker与虚拟机对比理解" class="headerlink" title="Docker与虚拟机对比理解"></a>Docker与虚拟机对比理解</h3><p><img src="https://bu.dusays.com/2025/04/09/67f66c4503075.png" alt="对比"></p><h3 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h3><p>C/S架构：Client客户端，Server服务端</p><p><strong>Docker Client</strong></p><p>Docker客户端，向服务端发起请求，比如下载镜像，管理容器声明周期</p><p><strong>Docker Daemon</strong></p><p>Docker的后台守护程序，包含：</p><ul><li><p>Docker Server：服务端，接收请求</p></li><li><p>Engine：容器引擎，负责执行任务</p></li></ul><p><strong>Docker Registry</strong></p><p>镜像仓库</p><h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p><strong><code>docker search jdk</code></strong> 用于查找jdk镜像的版本</p><p><strong><code>docker pull openjdk:11</code></strong> 把jdk的镜像拉取到本地，冒号用于指定版本</p><p><strong><code>docker images</code></strong> 查看本地镜像</p><p><strong><code>docker rmi 123456</code></strong> 删除id号为123456的<strong>本地镜像</strong></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><strong><code>docker ps</code></strong> 查看当前运行的容器</p><p><strong><code>docker ps -a</code></strong> 查看当前所有容器名称</p><p><strong><code>docker run [容器名称]</code></strong> 运行目标名称的容器，默认前台运行</p><blockquote><p><strong>前台运行vs后台运行</strong></p><p><strong>前台运行</strong>：启动容器时，将容器的输入输出与宿主机的终端相连，用户可以直接在当前终端与容器进行交互</p><p><strong>后台运行</strong>：容器在后台独立运行，不与宿主机的终端直接关联。容器启动后，命令行会立即返回，你可以继续在宿主机终端执行其他操作</p></blockquote><p><strong><code>docker run -d -p 80:81 [容器名称]</code></strong> 运行目标名称的容器，-d指定后台运行，-p指定容器监听主机80端口，若有请求则转发到容器内81端口</p><blockquote><p>因为资源隔离，所以容器内外网络不互通，eg内外都有80port，所以用到-p参数标识路由转发</p></blockquote><p><strong><code>docker run -d -P [容器名称]</code></strong> -P 参数的作用是让 Docker 自动在宿主机上选取一个可用的端口，并将其映射到容器内暴露(<code>EXPOSE</code>)的端口上，暴露端口指的是在<code>Dockerfile</code>里通过<code>EXPOSE</code>命令声明的容器内监听的端口</p><p><strong><code>docker rm 123456</code></strong> 删除id为123456的停止的<strong>容器</strong>，id不一定为123456，只要123456能定位到一个唯一id的容器即可</p><p><strong><code>docker rm -f 123456</code></strong> 强制删除id为123456的容器，无论是否运行中</p><p><strong><code>docker stop 123456</code></strong> 停止id为123465的容器</p><p><strong><code>docker start 123456</code></strong> 启动id为123456的容器</p><p><strong><code>docker run -d -name cont01 [容器名称]</code></strong> 启动目标容器并指定名称为cont01，后续操作可用名字代替id</p><p><strong><code>docker run --rm [容器名称]</code></strong> 运行容器，<code>rm</code>标识该容器停止后会自动删除</p><p><strong><code>docker run -d --restart on-failure:3 [容器名称]</code></strong> <code>--restart</code>标识重启策略，默认不重启；<code>on-failure</code>失败时重启，可以加上<code>:3</code>表示第三次部署失败就不重启了；<code>always</code>表示只要已关闭就自动重启</p><p><strong><code>docker run -d -P -e JAVA_ENV=dev -e JAVA_VM=G1 nginx</code></strong> 启动 <code>nginx</code> 容器时设置 <code>JAVA_ENV=dev</code> 和 <code>JAVA_VM=G1</code> 这两个环境变量</p><p><strong><code>docker inspect NAME|ID</code></strong> 查看docker对象的详细信息</p><p><strong><code>docker exec -it cont01 env</code></strong> exec命令是指定cont01容器，基于容器内终端（it），来执行env命令（显示环境变量）</p><p><strong><code>-m 8m</code></strong> 限制内存最大为8mb，<strong><code>--cpus 1</code></strong> 限制cpu最多用一个</p><p><strong><code>docker logs cont01</code></strong> 输出cont01容器的所有日志</p><p><strong><code>docker exec -it cont01 bash</code></strong> 进入容器cont01内部，并使用bash</p><h1 id="Docker进阶"><a href="#Docker进阶" class="headerlink" title="Docker进阶"></a>Docker进阶</h1><h2 id="数据卷Volume"><a href="#数据卷Volume" class="headerlink" title="数据卷Volume"></a>数据卷Volume</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>是容器外部的独立存储空间，即使容器被删除，数据卷仍会保留。</p></li><li><p>同一个数据卷可被多个容器同时挂载，所有容器对卷内数据的读写操作是实时同步的</p></li><li><p>容器可通过数据卷直接访问宿主机文件系统，高性能</p></li></ul><h3 id="绑定方式"><a href="#绑定方式" class="headerlink" title="绑定方式"></a>绑定方式</h3><h4 id="匿名绑定"><a href="#匿名绑定" class="headerlink" title="匿名绑定"></a>匿名绑定</h4><p><code>docker run -v /app/data nginx</code>Docker 自动创建无名称卷，存储路径为宿主机的 <code>Docker 数据目录/volumes/随机哈希</code></p><ul><li><p>容器删除后卷仍然存在，需要手动清理</p></li><li><p>容器启动时加 <code>--rm</code>，停止后卷会自动删除</p></li></ul><h4 id="具名绑定"><a href="#具名绑定" class="headerlink" title="具名绑定"></a>具名绑定</h4><p><code>docker run -d -v my-named-volume:/app/data my-image</code> 不关心存放的位置，只想持久化存储一些内容</p><ul><li><p>有自定义的名字，能够轻松识别和管理卷</p></li><li><p>除非手动删除，否则会一直存在</p></li></ul><h4 id="Bind-Mount"><a href="#Bind-Mount" class="headerlink" title="Bind Mount"></a>Bind Mount</h4><p>把宿主机的目录直接映射到容器内的目录</p><p><code>docker run -v /host/path:/container/path my-image</code> <code>/host/path</code> 是宿主机上的路径，<code>/container/path</code> 是容器内的挂载路径</p><ul><li><p>只要宿主机上的文件或目录存在，即使容器被删除，数据也不会丢失</p></li><li><p>可以挂载宿主机上的任意文件或目录，不受 Docker 卷存储管理的限制</p></li><li><p>宿主机和容器内的文件修改会实时同步</p></li></ul><h3 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure><h2 id="网络Network"><a href="#网络Network" class="headerlink" title="网络Network"></a>网络Network</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>是<code>Docker</code>对容器网络隔离的一项技术，提供了多种不同模式供用户使用，选择不同的网络模式来实现<strong>容器网络</strong>的互通以及的隔离</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul><li><p>容器间的网络隔离</p></li><li><p>实现部分容器之间的网络隔离</p></li><li><p>管理多个子网下的容器ip</p></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><p>提供了多种模式，可以定制化的为每个容器制定不同的网络</p></li><li><p>自定义网络模式，划分不同的子网|网关|dns等配置</p></li><li><p>实现网络互通</p><ul><li><p>实现不同子网之间的网络互通</p></li><li><p>基于容器名（主机名）的方式在网络内访问</p></li></ul></li></ul><h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><h4 id="bridge桥接模式（默认模式）"><a href="#bridge桥接模式（默认模式）" class="headerlink" title="bridge桥接模式（默认模式）"></a>bridge桥接模式（默认模式）</h4><p>在主机中创建一个<code>Docker0</code>的网桥，在<code>Docker0</code>创建一对虚拟网卡，有一半在主机上<code>vethxxx</code>，有一半在容器内<code>eth0</code></p><p><img src="https://bu.dusays.com/2025/04/09/67f66db2967ed.png" alt="bridgeMode"></p><h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>容器不再拥有自己的网络空间，而是直接与主机共享网络空间，基于该模式创建的容器对应的ip实际及时与主机为同一个子网，同一个网段</p><p><img src="https://bu.dusays.com/2025/04/09/67f66bd6546e7.png" alt="hostMode"></p><h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p><code>Docker</code>会拥有自己的网络空间，不与主机共享，在这个网络模式下的容器，不会被分配网卡&amp;ip&amp;路由等相关信息</p><ul><li><p>完全隔离，与外部任何机器都无网络访问，只与自己的io，本地网络127.0.0.1</p></li><li><p>绝对安全</p></li></ul><p><img src="https://bu.dusays.com/2025/04/09/67f66bd665669.png" alt="noneMode"></p><h4 id="Container模式"><a href="#Container模式" class="headerlink" title="Container模式"></a>Container模式</h4><p>不会创建自己的网络，与其他容器共享网络空间，直接使用指定容器的ip/端口</p><p><img src="https://bu.dusays.com/2025/04/09/67f66bd65e8c2.png" alt="containerMode"></p><h4 id="自定义网络模式（推荐）"><a href="#自定义网络模式（推荐）" class="headerlink" title="自定义网络模式（推荐）"></a>自定义网络模式（推荐）</h4><p>不适用<code>Docker</code>自带的网络模式，而是自己定制化自己持有的网络模式</p><p>命令：<code>docker network COMMOND</code></p><pre><code>Manage networksCommands:  connect     Connect a container to  a network  create      Create a network  disconnect  Disconnect a container from a network  inspect     Display detailed information on one or more networks  ls          List networks  prune       Remove all unused networks  rm          Remove one or more networks</code></pre><p><strong>为什么自定义网路中的容器能通过容器名ping通，但是bridge模式不行</strong></p><p>在<code>Docker</code>自定义网络中，<code>DNS</code>被深度集成以实现容器间的自动服务发现。当容器加入自定义网络时，<code>Docker</code>会将其容器名和<code>ip</code>地址注册到<code>DNS</code>服务器</p><p>bridge模式不嵌入DNS</p><h3 id="不同模式下的链接"><a href="#不同模式下的链接" class="headerlink" title="不同模式下的链接"></a>不同模式下的链接</h3><p><code>docker network connect wolfcode net1</code></p><p><img src="https://bu.dusays.com/2025/04/09/67f66bd6681e6.png" alt="contactBetweenTwoDifferentMode"></p><h2 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><ul><li><p><strong>构建镜像</strong>用的</p></li><li><p><code>Docker</code>为我们提供的一个用于自定义构建镜像的一个配置文件：描述如何构建一个对象</p></li><li><p>利用<code>Docker</code>提供的<code>build</code>命令，指定<code>Dockerfile</code>文件，就可以按照配置的内容将镜像构建出来</p></li></ul><h4 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h4><ul><li><p>作为开发者，需要将自己开发好的项目打包成<code>Docker</code>镜像，便于后面直接作为<code>Docker</code>容器运行</p></li><li><p>作为运维人员，需要构建更精简的基础设施服务镜像，满足公司的需求以及尽可能减少冗余的功能占用过多的资源</p></li></ul><h4 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h4><ul><li><p>可以自定义镜像内容</p></li><li><p>构建公共基础镜像减少其他镜像配置</p></li><li><p>开源程序快速部署</p></li><li><p>实现企业内容项目快速交付</p></li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><strong><code>FROM</code></strong></p><p>指定以什么镜像为基础镜像，在改进项的基础之上构建新的镜像</p><p>如果不想以任何镜像为基础：<code>FROM scratch</code></p><p>语法：</p><ul><li><p><code>FROM &lt;image&gt;</code></p></li><li><p><code>FROM &lt;image&gt;:&lt;tag&gt;</code></p></li><li><p><code>FRom &lt;image&gt;:&lt;digest&gt;</code></p></li></ul><p>以上三种写法，后两者为指定具体版本，第一种则使用<code>latest</code>也就是最新版</p><p><strong><code>MAINTAINER</code></strong></p><p>指定镜像的维护者</p><pre><code>MAINTAINER John Doe &lt;johndoe@example.com&gt; </code></pre><p><code>MAINTAINER</code> 指令指定了镜像的维护者是 John Doe，其邮箱为 <code>johndoe@example.com</code></p><p><em>Docker官方现已弃用MAINTAINER命令，他的功能可以用LABEL指令更灵活的实现</em></p><p><strong><code>LABEL</code></strong></p><p>为镜像|容器|卷添加元数据</p><p>语法</p><ul><li><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li></ul><p>可以在一条 <code>LABEL</code> 指令中定义多个键值对，也能使用多条 <code>LABEL</code> 指令。键值对之间用空格分隔，键和值之间用等号连接</p><p>eg</p><pre><code>LABEL maintainer=&quot;John Doe &lt;johndoe@example.com&gt;&quot;</code></pre><p><strong><code>ENV</code></strong></p><p>设置容器的环境变量，可以设置多个</p><p>语法：</p><ul><li><p><code>ENV &lt;key&gt; &lt;value&gt;</code></p></li><li><p><code>ENV &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...</code></p></li></ul><p><strong><code>RUN</code></strong></p><p><code>RUN</code> 指令在<strong>构建镜像</strong>期间执行，在 Dockerfile 中可以有多个 <code>RUN</code> 指令，每个 <code>RUN</code> 指令都会在镜像中创建一个新的层。为了减少镜像的层数和体积，建议将相关的命令组合在一个 <code>RUN</code> 指令中执行</p><p>语法：</p><ul><li><p><code>RUN &lt;command&gt;</code></p></li><li><p><code>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></p></li></ul><p>第一种写法直接写<code>shell</code>脚本即可</p><p>第二种写法类似于函数调用，第一个参数为可执行文件，后面的都是参数</p><p>eg</p><pre><code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></pre><p><code>-c</code> 后面跟着的 <code>&quot;echo hello&quot;</code> 会被当作 shell 命令来执行，所以直接调用 <code>/bin/bash</code> 来执行 <code>echo hello</code> 命令</p><p><strong><code>ADD</code></strong></p><p>复制命令，把<code>src</code>的文件复制到镜像的<code>dest</code>位置（从主机复制到容器）</p><p>语法：</p><ul><li><p><code>ADD &lt;src&gt; &lt;dest&gt;</code></p></li><li><p><code>ADD [&quot;&lt;src&gt;&quot;,&quot;&lt;dest&gt;&quot;</code></p></li></ul><p><strong><code>WORKDIR</code></strong></p><p>设置并<code>cd</code>到容器中的工作目录，如果该目录不存在则自动创建。</p><p>语法：</p><ul><li><code>WORKDIR /app</code></li></ul><p>在根目录下创建<code>app</code>目录</p><p><strong><code>VOLUME</code></strong></p><p>设置挂载目录，可以将主机中的指定目录挂载到容器中</p><p>语法：</p><ul><li><p><code>VOLUME [&quot;&lt;dir&gt;&quot;]</code></p></li><li><p><code>VOLUME &lt;dir&gt;</code></p></li><li><p><code>VOLUME &lt;dir&gt; &lt;dir&gt;</code></p></li></ul><p><strong><code>EXPOSE</code></strong></p><p>设置容器启动后要暴露的端口（容器在运行时会监听的网络端口）</p><p>语法：</p><ul><li><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt; ...]</code></li></ul><p><code>&lt;port&gt;</code>表示容器要监听的端口号,<code>&lt;protocol&gt;</code>是可选参数，用于指定端口使用的协议，默认值为 <code>tcp</code>，也可以设置为 <code>udp</code></p><p><em>注意：<code>EXPOSE</code>只是暴露端口，并没有与主机的端口形成映射。映射行为是在容器<code>run</code>的时候加<code>-p</code>参数实现的</em></p><p><strong><code>CMD</code></strong></p><p><code>CMD</code> 指令在<strong>容器</strong>启动时执行，在 Dockerfile 中只能有一个 <code>CMD</code> 指令，若有多个 <code>CMD</code> 指令，只有最后一个会生效</p><p>语法：</p><ul><li><p><code>CMD echo &quot;Hello world!&quot;</code></p></li><li><p><code>CMD [&quot;echo&quot;,&quot;Hello world!&quot;]</code></p></li></ul><p><strong><code>ENTRYPOINT</code></strong></p><p>用来设置容器启动时要执行的命令，并且这个命令不能被 <code>docker run</code> 后面的参数直接覆盖，它提供了一种固定容器启动行为的方式，常用于设置容器的主命令</p><p><strong><code>CMD</code>和<code>ENTRYPOINT</code>的区别</strong></p><ul><li><p>单独使用 <code>ENTRYPOINT</code>，<code>docker run</code> 后面添加的参数会被当作 <code>ENTRYPOINT</code> 命令的参数</p></li><li><p>单独使用 <code>CMD</code>，如果 <code>docker run</code> 后面添加了其他命令，<code>CMD</code> 指定的命令会被覆盖</p></li><li><p>当 <code>ENTRYPOINT</code> 和 <code>CMD</code> 结合使用时，<code>CMD</code> 提供的参数会作为 <code>ENTRYPOINT</code> 命令的默认参数，若 <code>docker run</code> 后面添加了参数，这些参数会替换 <code>CMD</code> 的默认参数</p></li></ul><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>基于一个现有的容器，构建一个新的镜像（image）</p><p><em>定制化操作不方便！</em></p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p><del>自己构建两个镜像练练手</del></p><p>eg</p><pre><code># 使用Python 3.9作为基础镜像FROM python:3.9-slim# 设置工作目录WORKDIR /app# 复制当前目录下的所有文件到工作目录COPY . /app# 安装应用所需的依赖RUN pip install --no-cache-dir -r requirements.txt# 暴露应用运行的端口EXPOSE 5000# 设置环境变量ENV FLASK_APP=app.pyENV FLASK_RUN_HOST=0.0.0.0# 定义容器启动时执行的命令CMD [&quot;flask&quot;, &quot;run&quot;]</code></pre><h2 id="仓库Registry"><a href="#仓库Registry" class="headerlink" title="仓库Registry"></a>仓库Registry</h2><ul><li><p>用于管理<code>Docker</code>的镜像</p></li><li><p>快速交付</p></li><li><p>便于镜像的重复利用</p></li></ul><p><img src="https://bu.dusays.com/2025/04/09/67f670340b283.png" alt="registry"></p><h3 id="常见仓库"><a href="#常见仓库" class="headerlink" title="常见仓库"></a>常见仓库</h3><ul><li><p><code>Docker Hub</code></p></li><li><p><code>Aliyun</code></p></li><li><p><code>Nexus</code></p></li><li><p><code>Harbor</code></p></li></ul><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p><strong>这块没啥理论上的，实际部署一下就会了</strong></p><p>针对容器声明周期的管理，对容器声明周期进行更快速方便的方式进行管理</p><ul><li><p>依赖管理，当一个容器必须在另一个容器运行完成后才能运行时，就需要进行依赖管理</p></li><li><p>副本数控制，容器有时候也需要集群，快速对容器集群进行弹性伸缩</p></li><li><p>配置共享，通过配置文件统一描述需要运行的服务相关信息，自动化的解析配置内容，并构建对应服务</p></li></ul><p><em>更简单的使用容器</em></p><h3 id="Docker-Compose-单机"><a href="#Docker-Compose-单机" class="headerlink" title="Docker Compose(单机)"></a>Docker Compose(单机)</h3><ul><li><p>基于构建好的镜像来<strong>创建和管理多个容器</strong></p></li><li><p>需求：在一台机器上部署多个容器</p></li><li><p><code>Docker-Compose</code>可以高效便捷的管理单机上运行的所有容器，通过<code>yaml</code>配置文件的方式完成之前执行<code>docker run</code>命令所设置的所有参数。</p></li></ul><p><img src="https://bu.dusays.com/2025/04/09/67f66bd6631c0.png" alt="dockerCompose"></p><h4 id="服务services"><a href="#服务services" class="headerlink" title="服务services"></a>服务services</h4><p>需要运行的容器配置，可以理解为原先用<code>docker run</code>命令后面跟的一系列配置信息，都配在这里面</p><h4 id="网络networks"><a href="#网络networks" class="headerlink" title="网络networks"></a>网络networks</h4><p><code>docker-compose</code>公共自定义网络管理，配置好以后，可以直接在<code>services</code>中引用该网络配置，这个配置可以多个<code>services</code>使用</p><h4 id="数据卷volums"><a href="#数据卷volums" class="headerlink" title="数据卷volums"></a>数据卷volums</h4><p><code>docker-compose</code>下的统一数据卷管理，可以给多个<code>services</code>使用</p><h3 id="Swarm-分布式"><a href="#Swarm-分布式" class="headerlink" title="Swarm(分布式)"></a>Swarm(分布式)</h3><p>做<code>docker</code>的公司写的，与<code>k8s</code>竞争</p><h2 id="Portainer可视化工具"><a href="#Portainer可视化工具" class="headerlink" title="Portainer可视化工具"></a>Portainer可视化工具</h2><p><strong>很推荐啊，天天只在命令行docker来docker去，快docker抑郁了</strong></p><pre><code>PS C:\Users\flypiggy&gt; docker --versionDocker version 28.0.1, build 068a01ePS C:\Users\flypiggy&gt; docker volume create portainer_dataportainer_dataPS C:\Users\flypiggy&gt; docker run -d -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ceUnable to find image &#39;portainer/portainer-ce:latest&#39; locallylatest: Pulling from portainer/portainer-cee2e06b27b87e: Pull complete1fed1531b45b: Pull complete04de093ad5ed: Pull complete86a7cce72d42: Pull completee09df2601140: Pull completeeae3ebf29ea8: Pull completec12aa3fbd31a: Pull completef111bda3f9a6: Pull complete81021110ed01: Pull complete4f4fb700ef54: Pull completeDigest: sha256:7f10a26bfdda3fc58295ea09b860117ecd86a642d66fb94ce1f27a4c221d4649Status: Downloaded newer image for portainer/portainer-ce:latest61cbab51c68ba3134921a2d7beb1ce320716682cac10f2094c0f08f3ae01c4d8</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go有意思的特性</title>
      <link href="/2025/01/24/go%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%89%B9%E6%80%A7/"/>
      <url>/2025/01/24/go%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>如题，记录一些自认为有趣的特性</p><p><strong>定时器</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器1执行完毕，协程定时器2终止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">&lt;-timer1.C</span><br><span class="line">fmt.Println(<span class="string">&quot;timer1 is done&quot;</span>)</span><br><span class="line"></span><br><span class="line">timer2 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开一个协程，此时程序一边运行协程func，一边跑下面的stop，因为timer2会立即stop，所以不会打印timer2 is done</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-timer2.C</span><br><span class="line">fmt.Println(<span class="string">&quot;timer2 is done&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">stop := timer2.Stop()</span><br><span class="line"><span class="keyword">if</span> stop &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;timer2 is stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打点器</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打点器700ms一次，程序等待3s，输出working</span></span><br><span class="line"><span class="comment">//有一个通道用来通知协程关闭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建打点器实例，后面需要释放这个实例</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">700</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//协程开始，用for循环不断得到打点器的值，输出ticker now</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">fmt.Println(<span class="string">&quot;Tick at&quot;</span>, t)</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">ticker.Stop() <span class="comment">//打点器停止</span></span><br><span class="line">ch &lt;- <span class="literal">true</span>    <span class="comment">//协程停止</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ticker stopped&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="image.png" alt="alt text"></p><p><strong>时间限制</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//速度限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">////七个任务，300ms一个，无处理爆发任务能力</span></span><br><span class="line"><span class="comment">//tick := time.Tick(300 * time.Millisecond) //打点器，ticker需要先实例且课手动停止，tick直接运行到程序结束</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//re := make(chan int, 7)</span></span><br><span class="line"><span class="comment">//for i := 1; i &lt;= 7; i++ &#123;</span></span><br><span class="line"><span class="comment">//re &lt;- i</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//close(re)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//for r := range re &#123;</span></span><br><span class="line"><span class="comment">//&lt;-tick</span></span><br><span class="line"><span class="comment">//fmt.Println(&quot;time &quot;, r, time.Now())</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//七个任务，300ms一个，可处理4个爆发任务（并发）</span></span><br><span class="line"><span class="comment">//能处理四个爆发任务，即存有四个时间令牌</span></span><br><span class="line">conti := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">conti &lt;- time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//开一个协程，隔300ms发送一个时间令牌表示可以处理事件+1</span></span><br><span class="line"><span class="comment">//通道conti容量是4</span></span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> time.Tick(<span class="number">300</span> * time.Millisecond) &#123;</span><br><span class="line">conti &lt;- t</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟任务</span></span><br><span class="line">requt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">requt &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(requt)</span><br><span class="line"><span class="comment">//任务处理，前四个在通道里已经有时间令牌了，很迅速的完成，后面三个保持300ms左右完成一个</span></span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> requt &#123;</span><br><span class="line">&lt;-conti</span><br><span class="line">fmt.Println(r, <span class="string">&quot; is done&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原子计数器</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子计数器，20个协程，每个累加50次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ops <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">50</span>; j++ &#123;</span><br><span class="line">atomic.AddUint64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//直接到地址处加1，所以多协程不会出错</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(ops)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>互斥锁</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line"><span class="comment">//aa叠加500+500次，bb叠加400次</span></span><br><span class="line"><span class="comment">//结构体里互斥锁，结构体方法：锁上，执行动作，解锁</span></span><br><span class="line"><span class="comment">//WaitGrounp保证协程</span></span><br><span class="line"><span class="comment">//单独函数执行累加</span></span><br><span class="line"><span class="comment">//使用WaitGrounp的时候，每个协程完毕后要运行wg.Done通知wg.WaitGroup任务结束，否则会一直被wg.Wait阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counti <span class="keyword">struct</span> &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">contner <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counti)</span></span> inc(name <span class="type">string</span>) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.contner[name] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := Counti&#123;</span><br><span class="line">contner: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;aa&quot;</span>: <span class="number">0</span>, <span class="string">&quot;bb&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wg := sync.WaitGroup&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">prog := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c.inc(name)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">go</span> prog(<span class="string">&quot;aa&quot;</span>, <span class="number">500</span>)</span><br><span class="line"><span class="keyword">go</span> prog(<span class="string">&quot;aa&quot;</span>, <span class="number">500</span>)</span><br><span class="line"><span class="keyword">go</span> prog(<span class="string">&quot;bb&quot;</span>, <span class="number">400</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(c.contner)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>panic&amp;revocer&amp;defer</strong></p><p>程序执行过程中遇到显式的panic会立即开始回溯调用栈，只有 defer 语句能在这个回溯过程中被执行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 defer 语句，在其中调用 recover 尝试捕获 panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 若 recover 返回值不为 nil，说明成功捕获到 panic</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;捕获到 panic:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;任务开始执行&quot;</span>)</span><br><span class="line">    <span class="comment">// 触发 panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;执行任务时出现严重错误&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;这行代码不会被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序开始&quot;</span>)</span><br><span class="line">    performTask()</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序继续执行，未崩溃&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间戳</strong></p><p>时间戳是一个表示特定时间点的单一数值，通常是从某个固定的起始时间（纪元）开始计算，到指定时间点所经过的时间量。在 Unix 系统中，纪元是 1970 年 1 月 1 日 00:00:00 UTC，常见的时间戳单位有秒、毫秒、微秒、纳秒等。例如，1672531200 这个秒级时间戳代表的是从 1970 年 1 月 1 日 00:00:00 UTC 到 2023 年 1 月 1 日 00:00:00 UTC 所经过的秒数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    now := time.Now()<span class="comment">//当下时间</span></span><br><span class="line">    secs := now.Unix()<span class="comment">//从纪年(到当下时间所经历的秒数</span></span><br><span class="line">    nanos := now.UnixNano()<span class="comment">//纳秒数量</span></span><br><span class="line">    fmt.Println(now)</span><br><span class="line"></span><br><span class="line">    millis := nanos / <span class="number">1000000</span></span><br><span class="line">    fmt.Println(secs)</span><br><span class="line">    fmt.Println(millis)</span><br><span class="line">    fmt.Println(nanos)</span><br><span class="line"></span><br><span class="line">    fmt.Println(time.Unix(secs, <span class="number">0</span>))</span><br><span class="line">    fmt.Println(time.Unix(<span class="number">0</span>, nanos))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个指定的时间对象</span></span><br><span class="line">    specifiedTime, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2024-10-01 12:00:00&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;时间解析错误:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定时间的秒级时间戳</span></span><br><span class="line">    timestamp := specifiedTime.Unix()</span><br><span class="line">    fmt.Println(<span class="string">&quot;指定时间的秒级时间戳:&quot;</span>, timestamp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go爬虫————页面抓取</title>
      <link href="/2024/12/17/go%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E6%8A%93%E5%8F%96/"/>
      <url>/2024/12/17/go%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E6%8A%93%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>跟着<a href="https://github.com/CocaineCong">小生凡一</a>老师做的，目的是熟悉网络的请求与响应&amp;数据库<br>从17号晚上开始敲了两三个点马马虎虎敲完了，不到200行，中间连接数据库，import等等耽误时间了，先复习一遍，然后找个静态网站抓一下  </p><p>不管代码有多少行，一个爬虫的核心流程通常是：<br> <strong>发送请求</strong> → <strong>获取响应</strong> → <strong>解析数据</strong> → <strong>保存结果</strong><br>所以接下来也按照这个步骤来过一遍两个项目</p><p>代码开源在了<a href="https://github.com/QUSTflypiggy/go-proj-self">go-proj-self</a></p><hr><h1 id="（一）抓取豆瓣top250"><a href="#（一）抓取豆瓣top250" class="headerlink" title="（一）抓取豆瓣top250"></a>（一）抓取豆瓣top250</h1><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><ul><li>构造客户端</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client:=http.Client</span><br></pre></td></tr></table></figure><ul><li>构造GET请求</li></ul><p><em>网页处按F12-&gt;点network-&gt;刷新-&gt;点TOP250-&gt;会有url，请求方法等</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req,err:=http.NewRequest(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;https://movie.douban.com/top250&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//请求体没有所以是nil</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">//如果出错</span></span><br><span class="line">fmt.Println(<span class="string">&quot;req err&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加请求头，伪造成浏览器请求，防止被反爬虫识别而失败</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>发送请求</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;请求失败&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()<span class="comment">//防止资源泄露</span></span><br></pre></td></tr></table></figure><h2 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h2><p>当请求成功时，可以正常获取响应</p><h2 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h2><p><strong>css选择器</strong> 在爬取静态页面的时候常用css选择器</p><ul><li>将 HTTP 响应的 Body 转换为一个可操作的 DOM 文档                                     </li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docDetail, err := goquery.NewDocumentFromReader(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;解析失败&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取节点信息<ul><li><code>Find(selector)</code>通过css选择器定位到html目标</li><li><code>Each(func(i int,s *goquery.Selection)&#123;&#125;)</code>遍历找到的所有元素，执行自定义逻辑</li></ul></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find根据css选择器找到目标html元素，each遍历元素执行自定义操作func</span></span><br><span class="line">docDetail.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).</span><br><span class="line">Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, s *goquery.Selection)</span></span> &#123; <span class="comment">//s是当前节点的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储元素，为插入数据库做准备</span></span><br><span class="line"><span class="keyword">var</span> data MovieData</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.hd &gt; a &gt; span:nth-child(1)&quot;</span>).Text() <span class="comment">//提取文本内容：标题</span></span><br><span class="line"></span><br><span class="line">img := s.Find(<span class="string">&quot;div &gt; div.pic &gt; a &gt; img&quot;</span>) <span class="comment">//找到img元素</span></span><br><span class="line">imgtem, ok := img.Attr(<span class="string">&quot;src&quot;</span>)            <span class="comment">//提取src</span></span><br><span class="line"></span><br><span class="line">info := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.bd &gt; p:nth-child(1)&quot;</span>).Text() <span class="comment">//简洁（导演，主演，年份）</span></span><br><span class="line"></span><br><span class="line">score := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.bd &gt; div &gt; span.rating_num&quot;</span>).Text() <span class="comment">//评分</span></span><br><span class="line">quote := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.bd &gt; p.quote &gt; span&quot;</span>).Text()        <span class="comment">//引言</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">director, actor, year := InfoSpite(info) <span class="comment">//构造InfoSpite函数解析字段提取主演，导演，年份</span></span><br><span class="line"></span><br><span class="line">data.Title = title</span><br><span class="line">data.Picture = imgtem</span><br><span class="line">data.Score = score</span><br><span class="line">data.Quote = quote</span><br><span class="line"></span><br><span class="line">data.Actor = actor</span><br><span class="line">data.Director = director</span><br><span class="line">data.Year = year</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> InsertData(data) &#123; <span class="comment">//插入数据库</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;插入失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;插入成功&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDB</span><span class="params">()</span></span> &#123; <span class="comment">//初始化连接数据库</span></span><br><span class="line"><span class="comment">//path := strings.Join([]string&#123;USERNAME, &quot;:&quot;, PASSWORD, &quot;@tcp(&quot;, HOST, &quot;:&quot;, PORT, &quot;)/&quot;, DBNAME, &quot;?charset=utf8&quot;&#125;, &quot;&quot;)</span></span><br><span class="line">path := USERNAME + <span class="string">&quot;:&quot;</span> + PASSWORD + <span class="string">&quot;@tcp(&quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT + <span class="string">&quot;)/&quot;</span> + DBNAME + <span class="string">&quot;?charset=utf8&quot;</span></span><br><span class="line"></span><br><span class="line">DB, _ = sql.Open(<span class="string">&quot;mysql&quot;</span>, path) <span class="comment">//打开数据库连接</span></span><br><span class="line"><span class="comment">//设置了连接的最大存活时间为 10（单位应该是与具体实现相关，通常是秒），意味着一个数据库连接在经过 10 个单位时间后，如果还没有被使用，将会被关闭回收，这样可以避免长时间闲置的连接占用过多资源</span></span><br><span class="line">DB.SetConnMaxLifetime(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//设定了最大空闲连接数为 5，也就是数据库连接池中最多允许存在 5 个处于空闲状态的连接，当空闲连接数超过这个值时，多余的空闲连接会被关闭，有助于合理控制资源使用和提升数据库连接性能</span></span><br><span class="line">DB.SetMaxIdleConns(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 DB.Ping() 语句来测试与数据库的连接是否可用</span></span><br><span class="line"><span class="comment">//它会向数据库发送一个简单的测试请求（比如 MySQL 中类似 SELECT 1 的操作）</span></span><br><span class="line"><span class="comment">//如果连接正常且数据库可以响应，则返回 nil ，否则返回一个包含错误信息的 error 类型值。</span></span><br><span class="line"><span class="keyword">if</span> err := DB.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;opon database fail&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;connect success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertData</span><span class="params">(movieData MovieData)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用全局变量 DB 来创建一个数据库事务 tx</span></span><br><span class="line">tx, err := DB.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Begin err &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备sol语句</span></span><br><span class="line">stmt, err := tx.Prepare(<span class="string">&quot;INSERT INTO movie_data(`Title`,`Director`,`Picture`,`Actor`,`Year`,`Score`,`Quote`)VALUES(?,?,?,?,?,?,?)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Prepare err &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stmt.Exec:通过预处理语句执行插入操作，将 MovieData 结构体中的字段逐个绑定到 SQL 语句中的占位符 ?</span></span><br><span class="line">_, err = stmt.Exec(movieData.Title, movieData.Director, movieData.Picture, movieData.Actor, movieData.Year, movieData.Score, movieData.Quote)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Exec err &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务，将sql语句写入数据库</span></span><br><span class="line">_ = tx.Commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="（二）抓取静态在线图书馆"><a href="#（二）抓取静态在线图书馆" class="headerlink" title="（二）抓取静态在线图书馆"></a>（二）抓取静态在线图书馆</h1><p><a href="http://books.toscrape.com/?">在线图书馆连接</a><br>跟上一个差不多，主要自己敲一遍，熟悉一下过程，有几个小点在这里列一下</p><ul><li>小星星图标转换成string</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scoreClass, exists := s.Find(<span class="string">&quot;article &gt; p&quot;</span>).Attr(<span class="string">&quot;class&quot;</span>)</span><br><span class="line">score := <span class="string">&quot;Unknown&quot;</span></span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line"><span class="comment">// scoreClass 可能是 &quot;star-rating Three&quot; 或类似字符串</span></span><br><span class="line">scoreParts := strings.Split(scoreClass, <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(scoreParts) &gt; <span class="number">1</span> &#123;</span><br><span class="line">score = scoreParts[<span class="number">1</span>] <span class="comment">// 提取 &quot;Three&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将评分转换为数字存储</span></span><br><span class="line">rating := <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> score &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;One&quot;</span>:</span><br><span class="line">rating = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Two&quot;</span>:</span><br><span class="line">rating = <span class="number">2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Three&quot;</span>:</span><br><span class="line">rating = <span class="number">3</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Four&quot;</span>:</span><br><span class="line">rating = <span class="number">4</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Five&quot;</span>:</span><br><span class="line">rating = <span class="number">5</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">rating = <span class="number">0</span> <span class="comment">// 如果没有匹配到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文字追踪到去掉空格和换行符</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rawStatus := s.Find(<span class="string">&quot;article &gt; div.product_price &gt; p.instock.availability&quot;</span>).Text()</span><br><span class="line">status := strings.TrimSpace(rawStatus) <span class="comment">// 去掉前后的空格和换行符</span></span><br></pre></td></tr></table></figure><h1 id="（三）动态网页"><a href="#（三）动态网页" class="headerlink" title="（三）动态网页"></a>（三）动态网页</h1><p><em>2024/12/19更新一下</em></p><p>爬的是b站评论，不同点在要先找到评论的接口api，然后把json格式转为struct存起来，再序列化出来用，代码开源在了github上<br>其余解析，存取没有什么不同，就没写完</p>]]></content>
      
      
      <categories>
          
          <category> go实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-Gin简明教程</title>
      <link href="/2024/12/04/go-Gin%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2024/12/04/go-Gin%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习来源<a href="https://geektutu.com/post/quick-go-gin.html">极客兔兔Gin简明教程</a>&amp;<a href="https://chatgpt.com/">ChatGPT</a></p><p>（老师的文章已经很全了）。本文是作为一个纯小白在学习兔老师教程的时候一些思考和资料查询。<br>需要先安装go和gin，这里建议直接看老师的教程，很细。  </p><h1 id="Gin是什么"><a href="#Gin是什么" class="headerlink" title="Gin是什么"></a>Gin是什么</h1><p>Gin 是一个用 Go 语言编写的轻量级、高性能的 Web 框架，因其简洁的设计和极高的处理性能，在开发 RESTful API 和 Web 服务时非常流行</p><p><strong>Gin 的特点</strong></p><ul><li>轻量级  <ul><li>代码量少，启动速度快，适合构建微服务。</li><li>没有包含过多的插件，保持核心简单，用户可以按需扩展。</li></ul></li><li>高性能<ul><li>Gin 使用 Go 的 net/http 标准库作为底层，性能表现极为优越。</li><li>使用 Radix 树 和 字符串查找优化 实现路由匹配，高效解析 HTTP 请求。</li></ul></li><li>中间件机制<ul><li>提供了中间件支持，用户可以灵活定义和扩展功能，例如日志、认证、错误处理等。</li></ul></li><li>开发友好<ul><li>提供了简洁的 API 和丰富的功能，如路由分组、参数绑定、JSON 数据处理等。</li><li>对于错误处理和调试有专门支持，如 Context 对象方便统一处理请求数据和响应。</li></ul></li></ul><h1 id="快速上手一个Gin程序"><a href="#快速上手一个Gin程序" class="headerlink" title="快速上手一个Gin程序"></a>快速上手一个Gin程序</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writen by geektutu</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="comment">//导入 gin 包，该包提供了构建 Web 应用所需的所有功能。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;Hello, Geektutu&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建Gin实例"><a href="#创建Gin实例" class="headerlink" title="创建Gin实例"></a>创建Gin实例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br></pre></td></tr></table></figure><p><code>gin.Default()</code>:</p><ul><li>返回一个 Gin 引擎实例，用于管理路由和中间件。</li><li>默认情况下，包含两个中间件：<ul><li>Logger：记录请求日志。</li><li>Recovery：自动处理程序中的崩溃并返回 500 错误。</li></ul></li></ul><h2 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;Hello, Geektutu&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="分段讲解"><a href="#分段讲解" class="headerlink" title="分段讲解"></a>分段讲解</h3><ul><li><code>r.GET(&quot;/&quot;)</code><ul><li>定义了一个HTTP GET方法的路由，路径为根路径/</li><li>告诉Gin什么样的URL（<a href="http://localhost:8080/）">http://localhost:8080/）</a> </li></ul></li><li><code>func(c *gin.Context)&#123;&#125;</code><ul><li>定义了一个匿名函数作为请求处理器</li><li><code>c</code>是一个<code>*gin.Context</code>的对象，封装了 HTTP 请求和响应的相关信息。（后文会细讲，这里作用是返回我们想要在浏览器上显示的信息）</li></ul></li><li><code>c.String(200, &quot;Hello, Geektutu&quot;)</code><ul><li>使用<code>c.String</code>方法向客户端返回纯文本相应</li><li><code>200</code>是HTTP状态码，表示请求成功</li></ul></li></ul><h2 id="启动web服务器"><a href="#启动web服务器" class="headerlink" title="启动web服务器"></a>启动web服务器</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br></pre></td></tr></table></figure><ul><li>用 r.Run()函数来让应用运行在本地服务器上，默认监听端口是 8080，可以传入参数设置端口，例如r.Run(“:9999”)即运行在 9999端口。</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">&quot;debug&quot;</span> mode. Switch to <span class="string">&quot;release&quot;</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using <span class="built_in">env</span>:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to <span class="built_in">set</span> a value.</span><br><span class="line">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies <span class="keyword">for</span> details.</span><br><span class="line">[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure><p><strong>浏览器访问 <a href="http://localhost:8080">http://localhost:8080</a></strong></p><p><img src="image.png" alt="alt text"></p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在 Gin 中，路由（Router）是处理 HTTP 请求并根据请求的不同路径和方法（如 GET、POST）来调用特定的处理函数（handler）的核心机制。Gin 路由通过 *gin.Engine 实例来管理和匹配这些请求。我们可以定义不同的路径和方法，并为每个请求指定对应的处理逻辑。</p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><ul><li><strong>GET</strong>：处理 GET 请求（从服务器获取数据）。</li><li>POST：处理 POST 请求（向服务器提交数据）。</li><li>PUT：处理 PUT 请求（更新服务器上的数据）。</li><li>DELETE：处理 DELETE 请求（删除服务器上的数据）。</li><li>PATCH：处理 PATCH 请求（局部更新资源）。</li></ul><h2 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;Who are you?&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="解析路径参数"><a href="#解析路径参数" class="headerlink" title="解析路径参数"></a>解析路径参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;Hello %s&quot;</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主要代码解释"><a href="#主要代码解释" class="headerlink" title="主要代码解释"></a>主要代码解释</h3><ul><li><code>r.GET(&quot;/user/:name&quot;, ...)</code><ul><li>r.GET 定义了一个 GET 请求 的路由。</li><li>“/user/:name” 中的 :name 是一个 动态路径参数。这意味着，name 不是一个固定的值，而是从请求的 URL 中动态提取的部分。</li><li>例如，URL <a href="http://localhost:8080/user/flypiggy">http://localhost:8080/user/flypiggy</a> 会使 name 变成 flypiggy。任何符合 /user/{name} 格式的请求都会匹配这个路由，并将 {name} 作为参数传递给处理函数。</li></ul></li><li><code>name := c.Param(&quot;name&quot;)</code><ul><li>c.Param(“name”) 从请求的 URL 中提取名为 name 的路径参数。</li><li>假设你访问的 URL 是 <a href="http://localhost:9999/user/flypiggy">http://localhost:9999/user/flypiggy</a>  ，c.Param(“name”) 会获取到 “flypiggy” 这个值，并将其赋值给变量 name。</li></ul></li><li><code>http.Statusok</code><ul><li>就是HTTP状态码200，表示请求成功</li></ul></li></ul><h2 id="获取Query参数"><a href="#获取Query参数" class="headerlink" title="获取Query参数"></a>获取Query参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">role := c.DefaultQuery(<span class="string">&quot;role&quot;</span>, <span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;%s is a %s&quot;</span>, name, role)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>name := c.Query(&quot;name&quot;)</code><ul><li>c.Query(“name”) 是从 URL 查询字符串中提取名为 name 的参数。</li><li>若没有name，则返回空字符串</li><li>查询字符串<ul><li>是 URL 中用来传递参数的一部分，通常位于 URL 的路径后面，紧跟着 ? 符号。它由一系列键值对组成，多个键值对之间通过 &amp; 符号分隔。</li><li><code>http://example.com/path?key1=value1&amp;key2=value2</code>，?后面就是查询字符串</li></ul></li></ul></li><li><code>role := c.DefaultQuery(&quot;role&quot;,&quot;teacher)</code><ul><li>从URL查询字符串中提取名为role的参数</li><li>若没有role，则默认值为teacher</li></ul></li></ul><h2 id="获取POST参数"><a href="#获取POST参数" class="headerlink" title="获取POST参数"></a>获取POST参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/form&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password := c.DefaultPostForm(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;000000&quot;</span>)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul><li><code>r.POST(&quot;/form&quot;, ...)</code><ul><li>r.POST 定义了一个 POST 请求 的路由。</li><li>路由的路径是 “/form”，这意味着它会匹配对 <a href="http://localhost:8080/form">http://localhost:8080/form</a> 的 POST 请求。</li></ul></li><li><code>username := c.PostForm(&quot;username&quot;)</code><ul><li>c.PostForm(“username”) 用来获取 POST 请求中的表单数据中名为 username 的参数。</li><li>假设客户端发送的请求体中包含 username=geektutu，那么 c.PostForm(“username”) 的值将是 “geektutu”。</li><li>如果请求中没有该参数，则返回空字符串。</li></ul></li><li><code>password := c.DefaultPostForm(&quot;password&quot;, &quot;000000&quot;)</code><ul><li>c.DefaultPostForm(“password”, “000000”) 用来获取 POST 请求中的表单数据中名为 password 的参数。如果没有该参数，则使用默认值 “000000”。</li></ul></li><li><code>c.JSON(http.StatusOK, gin.H&#123;...&#125;)</code><ul><li>c.JSON 用来返回一个 JSON 响应，http.StatusOK 表示 HTTP 状态码 200，表示请求成功。</li><li>gin.H 是 Gin 提供的一个便捷方法，用于创建一个键值对（map）。在这个例子中，返回的 JSON 包含 username 和 password 两个字段，分别对应从 POST 请求中获取的参数值。</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>浏览器地址栏无法直接构造 POST 请求。</li><li>推荐使用命令行的 cURL 或工具（如 Postman）来发送复杂的 POST 请求。</li><li>如果一定要用浏览器，最简单的方法是创造HTMl表单，这里不细说</li></ul><h2 id="Map参数（字典参数）"><a href="#Map参数（字典参数）" class="headerlink" title="Map参数（字典参数）"></a>Map参数（字典参数）</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">ids := c.QueryMap(<span class="string">&quot;ids&quot;</span>)</span><br><span class="line">names := c.PostFormMap(<span class="string">&quot;names&quot;</span>)</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;ids&quot;</span>:   ids,</span><br><span class="line"><span class="string">&quot;names&quot;</span>: names,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>ids := c.QueryMap(&quot;ids&quot;)</code><ul><li>这是从 查询字符串 中解析一个以 <code>ids</code> 为前缀的嵌套参数，返回值是一个 <code>map[string]string</code>。</li><li>查询字符串格式类似：  <code>?ids[Jack]=001&amp;ids[Tom]=002</code><br>解析后，ids 将是：<code>map[string]string&#123;&quot;Jack&quot;: &quot;001&quot;,&quot;Tom&quot;: &quot;002&quot;,&#125;</code></li></ul></li><li><code>names := c.PostFormMap(&quot;name&quot;)</code><ul><li>这是从 表单数据 中解析一个以 <code>names</code> 为前缀的嵌套参数，返回值是一个<code>map[string]string</code></li><li>表单数据格式类似：<code>names[a]=Sam&amp;names[b]=David</code>,解析后，names 将是：<code>map[string]string&#123;&quot;a&quot;: &quot;Sam&quot;,&quot;b&quot;: &quot;David&quot;,&#125;</code></li></ul></li></ul><h2 id="重定向-Redirect"><a href="#重定向-Redirect" class="headerlink" title="重定向(Redirect)"></a>重定向(Redirect)</h2><p>在 Gin 框架中，重定向 是指服务器收到一个请求后，告诉客户端（通常是浏览器）去访问另一个 URL。这样，客户端会再次发起请求到新的 URL。</p><h3 id="重定向的类型"><a href="#重定向的类型" class="headerlink" title="重定向的类型"></a>重定向的类型</h3><h4 id="301永久重定向"><a href="#301永久重定向" class="headerlink" title="301永久重定向"></a>301永久重定向</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/old&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;/new&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>客户端访问 /old 时，服务器告诉它目标地址是 /new。</li><li>浏览器可能会缓存这个重定向，下次直接访问 /new。</li><li>浏览器缓存重定向是指浏览器在收到一个重定向响应后，将这个重定向的信息保存在缓存中，并在之后访问相同的 URL 时自动按照重定向规则跳转到目标 URL，而无需再次向服务器发送请求。</li></ul><h4 id="302临时重定向"><a href="#302临时重定向" class="headerlink" title="302临时重定向"></a>302临时重定向</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/temp&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusFound, <span class="string">&quot;/another&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>客户端访问 /temp 时，被引导到 /another。</li><li>浏览器不会缓存重定向，下次依然会访问 /temp。</li></ul><h4 id="303重定向（常用于表单提交之后）"><a href="#303重定向（常用于表单提交之后）" class="headerlink" title="303重定向（常用于表单提交之后）"></a>303重定向（常用于表单提交之后）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/submit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusSeeOther, <span class="string">&quot;/result&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>适用于表单提交后引导用户到另一个页面。</li><li>如果表单通过 POST 提交，重定向后浏览器会使用 GET 方法访问 /result。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部重定向，请求转发</span></span><br><span class="line">r.GET(<span class="string">&quot;/goindex&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Request.URL.Path = <span class="string">&quot;/&quot;</span></span><br><span class="line">r.HandleContext(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>解释：<ul><li>当用户访问 /goindex 路由时：<ul><li>将 c.Request.URL.Path 的值从 /goindex 改为 /。</li><li>使用 r.HandleContext(c) 将修改后的请求重新交给 Gin 的路由引擎处理。</li></ul></li></ul></li><li>内部重定向的作用：<ul><li>不返回 HTTP 重定向响应。这与 c.Redirect 不同，HandleContext 是将当前请求直接路由到另一个处理函数。</li><li>在此例中，最终会路由到 / 的处理函数，并返回该处理函数的结果。</li></ul></li></ul><h2 id="分组路由"><a href="#分组路由" class="headerlink" title="分组路由"></a>分组路由</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">defaultHandler := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;path&quot;</span>: c.FullPath(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// group: v1</span></span><br><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1.GET(<span class="string">&quot;/posts&quot;</span>, defaultHandler)</span><br><span class="line">v1.GET(<span class="string">&quot;/series&quot;</span>, defaultHandler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// group: v2</span></span><br><span class="line">v2 := r.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v2.GET(<span class="string">&quot;/posts&quot;</span>, defaultHandler)</span><br><span class="line">v2.GET(<span class="string">&quot;/series&quot;</span>, defaultHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要每个路由都单独加上 /api/v1 前缀。你可以通过 路由分组 来实现对路由前缀的统一管理。路由分组会为组内的所有路由自动加上一个共同的前缀，这样你只需在创建路由组时定义一次前缀，然后在组内定义具体的路由，无需重复加前缀。</p><h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h1><h2 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/upload1&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">file, _ := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// c.SaveUploadedFile(file, dst)</span></span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;%s uploaded!&quot;</span>, file.Filename)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>file, _ := c.FormFile(&quot;file&quot;)</code><ul><li>c.FormFile(“file”) 用于从 HTTP 请求的 form-data 中提取文件。”file” 是表单字段的名称，它是客户端上传文件时指定的字段名。</li><li>这行代码获取到的 file 是一个 *multipart.FileHeader 类型的对象，包含了上传文件的详细信息（如文件名、大小、类型等）。</li><li>file.Filename：上传文件的文件名。</li><li>file.Size：上传文件的大小。</li><li>file.Header：上传文件的额外信息，如文件的 MIME 类型。</li></ul></li></ul><blockquote><p>注意：c.FormFile() 返回的 file 对象是文件的元数据，并不是文件本身的数据流。如果要保存文件，可以使用 c.SaveUploadedFile() 方法。</p></blockquote><ul><li><p><code>c.String(http.StatusOK, &quot;%s uploaded!&quot;, file.Filename)</code></p><ul><li>这行代码通过 c.String 返回一个字符串响应，表示文件上传成功，并且展示上传文件的名称。</li><li>http.StatusOK 表示 HTTP 状态码 200，表示请求成功。</li><li>file.Filename 变量会替换字符串中的 %s，显示上传的文件名。</li></ul></li></ul><h2 id="多个文件"><a href="#多个文件" class="headerlink" title="多个文件"></a>多个文件</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/upload2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// Multipart form</span></span><br><span class="line">form, _ := c.MultipartForm()</span><br><span class="line">files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">log.Println(file.Filename)</span><br><span class="line"><span class="comment">// c.SaveUploadedFile(file, dst)</span></span><br><span class="line">&#125;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="渲染html模板"><a href="#渲染html模板" class="headerlink" title="渲染html模板"></a>渲染html模板</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line"><span class="comment">//这行代码告诉 Gin 加载 templates/ 目录下的所有模板文件。LoadHTMLGlob 会加载符合指定模式的文件，这里是 templates/ 文件夹中的所有文件。</span></span><br><span class="line"></span><br><span class="line">stu1 := &amp;student&#123;Name: <span class="string">&quot;Geektutu&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">stu2 := &amp;student&#123;Name: <span class="string">&quot;Jack&quot;</span>, Age: <span class="number">22</span>&#125;</span><br><span class="line">r.GET(<span class="string">&quot;/arr&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;arr.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line">        <span class="comment">//&quot;arr.tmpl&quot; 是要渲染的模板文件名，假设该文件存在于 templates/ 文件夹中。</span></span><br><span class="line">        <span class="comment">//gin.H&#123;&#125; 是 Gin 提供的一个便捷方法，表示一个 map[string]interface&#123;&#125;，用于将数据传递到模板中。在这里传递了两个字段</span></span><br><span class="line"><span class="string">&quot;title&quot;</span>:  <span class="string">&quot;Gin&quot;</span>,</span><br><span class="line"><span class="string">&quot;stuArr&quot;</span>: [<span class="number">2</span>]*student&#123;stu1, stu2&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>在 Gin 中，中间件（Middleware）是用于在请求处理过程中的“请求-响应”链条中间进行拦截和处理的函数。它通常用于执行一些通用操作，例如日志记录、认证、授权、错误处理等。中间件可以在请求到达路由处理函数之前，或者在响应返回客户端之前，执行一些特定的操作。</p><h2 id="中间件的定义"><a href="#中间件的定义" class="headerlink" title="中间件的定义"></a>中间件的定义</h2><p>Gin 中的中间件是一个函数类型，签名为</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span></span><br></pre></td></tr></table></figure><p>其中，*gin.Context 是 Gin 中的上下文对象，提供了访问请求和响应的功能。</p><h2 id="如何使用中间件"><a href="#如何使用中间件" class="headerlink" title="如何使用中间件"></a>如何使用中间件</h2><p>在 Gin 中，可以使用 <code>r.Use()</code> 来为路由或路由组添加中间件。一个应用可以有多个中间件，Gin 会按添加顺序依次执行这些中间件。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>通过 <code>r.Use()</code> 可以添加全局中间件，意味着所有路由都会经过这些中间件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 Gin 路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的中间件，记录请求的路径</span></span><br><span class="line">r.Use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Request path:&quot;</span>, c.Request.URL.Path)</span><br><span class="line">c.Next() <span class="comment">// 调用下一个中间件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由</span></span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><p>如果只想为某些路由添加中间件，可以在路由或路由组上使用 Use()。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 Gin 路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由组，只有该组下的路由才会使用该中间件</span></span><br><span class="line">api := r.Group(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">api.Use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;API request&quot;</span>)</span><br><span class="line">c.Next() <span class="comment">// 调用下一个中间件或处理函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由</span></span><br><span class="line">api.GET(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;User list&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> Gin </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-net/http标准库简明教程</title>
      <link href="/2024/12/02/go-net&amp;http%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2024/12/02/go-net&amp;http%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天懒了（bushi），快赶赶进度…<br>学习来源<a href="https://chatgpt.com/">ChatGPT</a>&amp;&amp;<a href="https://gobyexample-cn.github.io/http-clients">Go by example</a><br>本文会包括go的net/http标准库等基础知识！零基础小白请放心使用!<br>会有涉及计网的一点知识 <del>(本人也正在cs144里挣扎)</del><br><del>好难过下周要考计组和数据结构</del><br>长文预警！！！</p><h1 id="Go的net-http标准库"><a href="#Go的net-http标准库" class="headerlink" title="Go的net/http标准库"></a>Go的net/http标准库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>net/http 是什么<br>它是 Go 标准库中用来处理 HTTP 请求和响应的模块，提供了构建 Web 服务的基本功能。  </li><li>核心组件  <ul><li>http.Server：表示 HTTP 服务器。  </li><li>http.Request：表示 HTTP 请求。  </li><li>http.ResponseWriter：用于构造 HTTP 响应。  </li><li>路由与处理器：通过 Handler 接口和 ServeMux 路由器来实现。  </li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, %s!&quot;</span>, r.URL.Path[<span class="number">1</span>:]) <span class="comment">// 响应内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler) <span class="comment">// 注册处理函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Server is running on http://localhost:8080&quot;</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 启动服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，访问 <a href="http://localhost:8080/Go，浏览器将显示：Hello">http://localhost:8080/Go，浏览器将显示：Hello</a>, Go!</p><h2 id="分块详细解释"><a href="#分块详细解释" class="headerlink" title="分块详细解释"></a>分块详细解释</h2><h3 id="启动HTTP服务器"><a href="#启动HTTP服务器" class="headerlink" title="启动HTTP服务器"></a>启动HTTP服务器</h3><p><code>http.ListenAndServe</code>  </p><p>用于启动HTTP服务器  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 参数：  </span></span><br><span class="line"><span class="string">  - :8080：监听的端口。  </span></span><br><span class="line"><span class="string">  - nil：表示使用默认的路由器（http.DefaultServeMux）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 自定义`</span><span class="string">`http.Server`</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 Go 的 net/http 标准库中，http.Server 是一个结构体，它表示一个 HTTP 服务器。相比直接使用 http.ListenAndServe，通过自定义 http.Server，可以对服务器的行为进行更细粒度的控制，比如设置超时时间、TLS 配置、监听地址等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### `</span><span class="string">`http.Server`</span><span class="string">`的结构</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr              <span class="type">string</span>           <span class="comment">// 监听地址（如 &quot;:8080&quot;）</span></span><br><span class="line">Handler           http.Handler     <span class="comment">// 请求处理器，默认是 http.DefaultServeMux</span></span><br><span class="line">ReadTimeout       time.Duration    <span class="comment">// 读取请求头的最大时间</span></span><br><span class="line">WriteTimeout      time.Duration    <span class="comment">// 写入响应的最大时间</span></span><br><span class="line">IdleTimeout       time.Duration    <span class="comment">// 连接空闲时间（HTTP/1.1 的 Keep-Alive）</span></span><br><span class="line">MaxHeaderBytes    <span class="type">int</span>              <span class="comment">// 请求头的最大字节数</span></span><br><span class="line">TLSConfig         *tls.Config      <span class="comment">// TLS 配置（用于 HTTPS）</span></span><br><span class="line">ConnState         <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span> <span class="comment">// 连接状态回调</span></span><br><span class="line">ErrorLog          *log.Logger      <span class="comment">// 自定义错误日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求处理器-Handler"><a href="#请求处理器-Handler" class="headerlink" title="请求处理器(Handler)"></a>请求处理器(Handler)</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>Handler 是 Go 中处理 HTTP 请求的一个接口，它定义了以下方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ResponseWriter：<br>用于构建和发送 HTTP 响应。<br>通过它可以设置状态码、响应头以及响应体。  </li><li>Request：<br>表示客户端的 HTTP 请求。<br>包含请求方法、URL、头信息、表单数据等。  </li></ul><p>总结：Handler 是处理 HTTP 请求并返回 HTTP 响应的逻辑核心。</p><h4 id="实现Handler的两种方式"><a href="#实现Handler的两种方式" class="headerlink" title="实现Handler的两种方式"></a>实现Handler的两种方式</h4><h5 id="1-实现http-Handler接口"><a href="#1-实现http-Handler接口" class="headerlink" title="(1)实现http.Handler接口"></a>(1)实现<code>http.Handler</code>接口</h5><p>任何实现了<code>ServeHTTP(w http.ResponseWriter, r *http.Request)</code>方法的类型都可以作为一个 Handler。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line"><span class="comment">//h *myHandler是一个指针接收者，表示ServeHTTP 方法与 myHandler 类型的指针绑定</span></span><br><span class="line"><span class="comment">//http.ResponseWriter 是一个接口，用于构造并发送 HTTP 响应给客户端</span></span><br><span class="line"><span class="comment">//*http.Request 是一个指向请求对象的指针,封装了客户端发来的 HTTP 请求的全部信息</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, you&#x27;ve hit %s\n&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="comment">//r.URL 是标准库 net/url 定义的 url.URL 结构体，用来解析和存储 URL 的详细信息。</span></span><br><span class="line"><span class="comment">//fmt.Fprintf 是 Go 语言中的一个非常常用的函数，它属于 fmt 包</span></span><br><span class="line"><span class="comment">//用于将格式化的字符串输出到指定的 io.Writer 接口对象中，而不是直接输出到控制台。</span></span><br><span class="line"><span class="comment">//与 fmt.Printf 和 fmt.Println 等标准输出函数不同，fmt.Fprintf 可以将输出定向到文件、网络连接、HTTP 响应等任何实现了 io.Writer 接口的对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := &amp;myHandler&#123;&#125;</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, handler)</span><br><span class="line"><span class="comment">//func ListenAndServe(addr string, handler http.Handler) error</span></span><br><span class="line"><span class="comment">//addr string指定服务器的监听地址，包括 IP 和端口号。</span></span><br><span class="line"><span class="comment">//handler http.Handler处理 HTTP 请求的对象，通常是一个实现了 http.Handler 接口的实例。</span></span><br><span class="line"><span class="comment">//启动一个HTTP服务端，持续监听8080端口，直到收到客户端请求</span></span><br><span class="line"><span class="comment">//如果没有指定 IP 地址或域名，那么访问的默认是本机</span></span><br><span class="line">    <span class="comment">//当浏览器发起请求（通过 TCP 协议连接到 localhost:8080）时，服务器接收这个连接</span></span><br><span class="line">    <span class="comment">//解析收到的 HTTP 请求，将请求分发给注册的处理器 handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在terminal中键入<code>go run main.go</code>，然后在浏览器中键入<code>http://localhost:8080/hello</code>,得到<code>Hello, you&#39;ve hit /hello</code></p><p>这个过程中，浏览器相当于客户端，浏览器通过url(<a href="http://localhost:8080/hello)构造出http请求，然后通过DNS解析把域名换算成ip地址，这样客户端知道目标服务器是谁，然后建立tcp/ip连接，再把构造出的http请求发送到目标服务器，在这里也就是把请求发送到本机的8080端口。Go程序相当于服务端，收到并解析http请求，把请求分发给注册的处理器handler。">http://localhost:8080/hello)构造出http请求，然后通过DNS解析把域名换算成ip地址，这样客户端知道目标服务器是谁，然后建立tcp/ip连接，再把构造出的http请求发送到目标服务器，在这里也就是把请求发送到本机的8080端口。Go程序相当于服务端，收到并解析http请求，把请求分发给注册的处理器handler。</a>  </p><p>在 Go 中，http 包提供了一个非常核心的功能：通过 HTTP 路由将不同的请求（通常是 HTTP 方法和路径的组合）指向特定的处理器（Handler）。这个过程叫做 注册。</p><h5 id="2-使用-http-HandlerFunc"><a href="#2-使用-http-HandlerFunc" class="headerlink" title="(2)使用 http.HandlerFunc"></a>(2)使用 <code>http.HandlerFunc</code></h5><p>Go 提供了一个便利的方法，可以将普通函数直接用作 Handler。这是通过类型 http.HandlerFunc 实现的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, you&#x27;ve hit %s\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, myHandler) <span class="comment">// 直接注册处理函数</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/test</code>将返回<code>Hello, you&#39;ve hit /test</code></p><p>如何实现的？<br>http.HandleFunc 的底层实现会将你传递的函数（如 myHandler）转为一个匿名的结构体，并为这个结构体实现 ServeHTTP 方法。这个匿名结构体的 ServeHTTP 方法就是你提供的 myHandler 函数。可以理解为 http.HandleFunc 自动为你完成了接口的实现。</p><h3 id="HTTP-请求对象-http-Request"><a href="#HTTP-请求对象-http-Request" class="headerlink" title="HTTP 请求对象 (http.Request)"></a>HTTP 请求对象 (http.Request)</h3><p>http.Request 是 Go 中处理 HTTP 请求的核心结构体，包含了许多关于请求的详细信息，包括请求方法、URL、头部、请求体等。通过这个结构体，你可以访问并处理各种与 HTTP 请求相关的数据，进而实现 HTTP 服务的功能。  </p><p>在本地显示读取控制。</p><h4 id="http-Request的主要字段（仅举例两个）"><a href="#http-Request的主要字段（仅举例两个）" class="headerlink" title="http.Request的主要字段（仅举例两个）"></a><code>http.Request</code>的主要字段（仅举例两个）</h4><ol><li><p><code>Method</code>（请求方法）</p><ul><li>类型：string</li><li>描述：表示 HTTP 请求的类型，如 GET、POST、PUT、DELETE 等。</li><li>例如，如果是一个 GET 请求，Method 会是 “GET”，如果是一个 POST 请求，Method 会是 “POST”。</li><li>例子：r.Method 可以帮助你判断请求的类型。</li></ul></li><li><p><code>URL</code>（请求的URL）</p><ul><li>类型：*url.URL</li><li>描述：表示客户端请求的 URL 地址。这个字段是一个指向 url.URL 结构体的指针，包含了完整的 URL 信息。</li><li>通过 r.URL.Path，你可以获取请求的路径（例如 /hello）。而 r.URL.Query() 可以用于获取 URL 查询参数（如 ?name=John）。</li><li>例子：<ul><li>r.URL.Path：/hello 代表访问路径。</li><li>r.URL.RawQuery：查询字符串部分，例如 name=John&amp;age=30。</li></ul></li></ul></li></ol><h3 id="HTTP-响应对象-http-ResponseWriter"><a href="#HTTP-响应对象-http-ResponseWriter" class="headerlink" title="HTTP 响应对象 (http.ResponseWriter)"></a>HTTP 响应对象 (http.ResponseWriter)</h3><p>示例代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line"><span class="comment">// 设置响应状态码为 201 Created</span></span><br><span class="line">w.WriteHeader(http.StatusCreated)</span><br><span class="line"><span class="comment">// 写入响应体内容</span></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, client!&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器，监听端口 8080</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h4><p>代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br></pre></td></tr></table></figure></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><strong>响应头（HTTP Headers）</strong>是服务器向客户端提供的关于响应的元信息。</li><li>Content-Type 是一个常用的响应头，它告诉客户端响应体的内容类型和格式，帮助客户端正确解析和处理数据。</li><li><p>告知客户端数据类型：<br>客户端需要知道返回的数据是什么类型，以便正确解析。例如：  </p><ul><li>text/plain：表示纯文本。</li><li>text/html：表示 HTML 文档。</li><li>application/json：表示 JSON 数据。  </li></ul><p>如果没有正确设置，客户端可能会错误地解析或显示数据。</p></li><li><p>支持不同的客户端  </p><ul><li>浏览器、移动设备、API 客户端等都依赖 Content-Type 来决定如何处理服务器返回的数据。</li><li>例如，Content-Type: text/html 会让浏览器将响应当作网页渲染，而 Content-Type: application/json 会让 API 客户端将其解析为 JSON 对象。</li></ul></li></ul><h4 id="设置响应状态码"><a href="#设置响应状态码" class="headerlink" title="设置响应状态码"></a>设置响应状态码</h4><p>代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.WriteHeader(http.StatusCreated)</span><br></pre></td></tr></table></figure><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><blockquote><p>状态码的作用是面向客户端的  </p></blockquote><ul><li><p>客户端通过状态码判断请求结果</p><ul><li>状态码如 200 OK 表示请求成功。</li><li>状态码如 404 Not Found 表示客户端请求的资源不存在。</li><li>状态码如 500 Internal Server Error 表示服务器内部出了问题。</li></ul></li><li><p>客户端行为会依赖状态码</p><ul><li>浏览器看到 301 Moved Permanently 会自动重定向到新的 URL。</li><li>API 客户端根据 401 Unauthorized 提示用户需要登录。</li><li>搜索引擎看到 503 Service Unavailable 会知道服务器暂时不可用，稍后再尝试抓取页面。</li></ul></li></ul><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>HTTP 客户端主要用于发送 HTTP 请求到指定的服务器，并接收服务器的响应。net/http 提供了一些简单易用的函数和类型，例如 http.Get、http.Post、http.Client 等。</p><h4 id="核心类型-amp-函数"><a href="#核心类型-amp-函数" class="headerlink" title="核心类型&amp;函数"></a>核心类型&amp;函数</h4><p>(1) http.Client<br>http.Client 是一个可配置的 HTTP 客户端，用于发送请求和接收响应。<br>默认客户端是 http.DefaultClient。<br>(2) http.Request<br>表示一个 HTTP 请求，包含请求方法、URL、头部、请求体等。<br>(3) http.Response<br>表示一个 HTTP 响应，包含状态码、头部、响应体等。<br>(4) 快捷方法  </p><ul><li>http.Get：发送简单的 GET 请求。</li><li>http.Post：发送简单的 POST 请求。</li><li>http.Head、http.PostForm 等：发送其他类型的请求。</li></ul><p><del>懒得写例子直接解释gobyexample里的</del></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span><span class="comment">//提供缓冲I/O操作</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://gobyexample.com&quot;</span>)</span><br><span class="line"><span class="comment">//发送一个http.Get到http://gobyexample.com</span></span><br><span class="line"><span class="comment">//返回响应对象http.Response和error</span></span><br><span class="line"><span class="comment">//resp是一个响应对象，包含状态码，头部和响应体</span></span><br><span class="line"><span class="comment">//err表示是否出错，如果不为nil则代表出错</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line"><span class="comment">//若出错，则终止程序，输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"><span class="comment">//保证在resp.Body使用完后立即关闭</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response status:&quot;</span>, resp.Status)<span class="comment">//打印状态码</span></span><br><span class="line"></span><br><span class="line">    scanner := bufio.NewScanner(resp.Body)</span><br><span class="line"><span class="comment">//创造扫描器，逐行读取响应体中的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; scanner.Scan() &amp;&amp; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">//按行读取响应体，若有下一行则返回true</span></span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描是否有错误，有错误用panic抛出</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP服务端"><a href="#HTTP服务端" class="headerlink" title="HTTP服务端"></a>HTTP服务端</h3><p>HTTP 服务端用于处理客户端的 HTTP 请求并返回响应。Go 提供了一个高效的 HTTP 服务器实现，支持路由处理和并发。</p><h4 id="核心类型-amp-函数-1"><a href="#核心类型-amp-函数-1" class="headerlink" title="核心类型&amp;函数"></a>核心类型&amp;函数</h4><p>(1) http.Handler<br>接口，表示 HTTP 请求的处理器。<br>需要实现 ServeHTTP(w http.ResponseWriter, r *http.Request) 方法。<br>(2) http.Server<br>表示一个 HTTP 服务器，包含监听地址、处理器和其他配置。<br>默认服务器是通过 http.ListenAndServe 启动的。<br>(3) http.ServeMux<br>默认的路由器，负责将请求分发给对应的 Handler。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;hello\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headers</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, headers := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">        <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;%v: %v\n&quot;</span>, name, h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/headers&quot;</span>, headers)</span><br><span class="line"><span class="comment">//注册了两个处理器</span></span><br><span class="line"><span class="comment">//一个打印hello，一个打印所有请求头</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-单元测试</title>
      <link href="/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>零基础小白可放心食用！有很多概念解释比如匹配or通配符等等，一起加油！</p></blockquote><p>学习来源：  </p><ul><li><a href="https://geektutu.com/post/quick-go-test.html">极客兔兔-Go Test单元测试简明教程</a></li><li><a href="https://chatgpt.com/">ChatGPT</a></li></ul><p>Go 的单元测试是 Go 语言中内置的一个重要功能，支持开发者快速验证代码的正确性。通过标准库 testing 和相关工具（如 go test），你可以编写简洁、高效的单元测试用例。</p><h1 id="单元测试基本概念"><a href="#单元测试基本概念" class="headerlink" title="单元测试基本概念"></a>单元测试基本概念</h1><ul><li>单元测试是指对代码中最小的可测试部分（如函数或方法）进行验证，以确保其行为符合预期。  </li><li>在 Go 中，单元测试文件以 _test.go 为后缀，测试函数以 Test 开头。  </li><li>Go 的测试框架是内置的，运行 go test 命令即可执行测试。  </li></ul><h1 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h1><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example/</span><br><span class="line">    |--calc.go</span><br><span class="line">    |--calc_test.go</span><br></pre></td></tr></table></figure><br>例如calc.go代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func Add(a int, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Mul(a int, b int) int &#123;</span><br><span class="line">    return a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则在同一个包中的calc_test.go可以这么写<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">if ans := Add(1, 2); ans != 3 &#123;</span><br><span class="line">t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ans := Add(-10, -20); ans != -30 &#123;</span><br><span class="line">t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>文件名必须以 _test.go 结尾。</li><li>测试函数：<ul><li>名称必须以 Test 开头，例如 TestAdd。</li><li>参数为 *testing.T 类型，用于报告测试失败和日志。</li></ul></li><li>测试文件和函数需要在同一个包中。</li></ul><blockquote><p><em>*testing.T 是用于单元测试的参数类型，表示测试上下文。它提供了一系列方法，用于报告测试状态、记录日志、跳过测试等。</em>  </p><p><strong>testing.B 是基准测试的参数类型，表示基准测试上下文。基准测试用于衡量代码的性能，通过* </strong>testing.B 提供的方法控制基准测试的运行。*</p><p><em>*testing.M 是 TestMain 函数的参数类型，用于控制测试的整个生命周期。TestMain 是所有测试的入口点，可以在运行测试前后进行全局的初始化和清理工作。</em>    </p></blockquote><p>运行go test，改package下所有测试都会被运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">ok      example 0.009s</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">或 go <span class="built_in">test</span> -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   TestMul</span><br><span class="line">--- PASS: TestMul (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>覆盖率</strong><br>衡量测试用例对代码检查程度的指标，表示被测试的代码中实际被执行的部分占整个代码的比例。Go 提供了内置工具来分析测试覆盖率，通过 -cover 参数可以快速查看。<br>覆盖率通常以百分比表示，用来评估测试的有效性。测试覆盖率有以下几种类型：  </p><ul><li>语句覆盖率（Statement Coverage）：被执行的代码语句占总语句数的比例。</li><li>分支覆盖率（Branch Coverage）：被测试的代码中，分支条件（如 if 和 else）被覆盖的比例。</li><li>函数覆盖率（Function Coverage）：被调用的函数占总函数数的比例。  </li></ul><p>在 Go 中，-cover 参数默认显示语句覆盖率。  </p><p>如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run TestAdd -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>匹配，通配符与正则表达式</strong></p><ul><li>匹配：在 Go 的单元测试中，-run 参数用于指定运行哪些测试用例，通过匹配测试函数的名称来决定哪些测试会被执行。具体来说，根据你提供的通配符或正则表达式，与测试函数的名字进行对比。如果函数的名字符合你给定的模式，那么该测试用例会被运行。  </li><li><p>匹配的种类：</p><ul><li><p>运行指定测试<br>运行TestAdd<code>go test -run=TestAdd</code>  </p></li><li><p>使用通配符  </p><ul><li>运行所有以Test开头的测试<code>go test -run=Test*</code></li></ul></li><li><p>使用正则表达式<br>运行以 Test 开头且包含 Add 或 Subtract 的测试函数<code>go test -run=^Test(Add|Subtract)$</code></p></li></ul></li></ul><h1 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h1><p>在 Go 中，子测试是一种强大的功能，可以在一个测试函数中组织和运行多个相关的子测试。通过使用子测试，你可以对一组逻辑相关的测试进行分组，并更清晰地描述每个测试的意图。这种功能通常用在参数化测试或者复杂场景的分层测试中。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>子测试是通过 t.Run(name, func(t *testing.T)) 创建的：  </p><ul><li>name：为子测试指定一个描述性名称，用于标识这个测试。</li><li>匿名函数 func(t *testing.T)：定义子测试的逻辑。</li><li>子测试会在父测试中运行，可以嵌套多层，形成类似层级结构的测试组织方式。</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被测试函数,应该在同源的另一个文件里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">//结构体切片tests，定义了一组测试输入和期望输出</span></span><br><span class="line">        </span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">a, b     <span class="type">int</span></span><br><span class="line">expected <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">        <span class="comment">//子测试的名字会出现，更容易定位错误</span></span><br><span class="line">&#123;<span class="string">&quot;Add positives&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add negatives&quot;</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add mixed&quot;</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历测试用例并运行子测试</span></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="comment">//匿名函数，内联在t.Run中</span></span><br><span class="line">            <span class="comment">//每个子测试调用时，匿名函数被立即执行</span></span><br><span class="line"><span class="comment">//匿名函数内部代码定义了子测试的具体行为</span></span><br><span class="line">            result := Add(tt.a, tt.b)</span><br><span class="line"><span class="keyword">if</span> result != tt.expected &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Add(%d, %d) = %d; want %d&quot;</span>, tt.a, tt.b, result, tt.expected)</span><br><span class="line">                <span class="comment">//t.Errorf 用于记录一条格式化的错误信息，同时标记当前测试失败。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行<code>go test -v</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">=== RUN   TestAdd/Addnec</span><br><span class="line">=== RUN   TestAdd/Addpos</span><br><span class="line">=== RUN   TestAdd/Addmix</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addnec (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addpos (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addmix (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      go-practice     0.360s</span><br></pre></td></tr></table></figure><h3 id="嵌套子测试"><a href="#嵌套子测试" class="headerlink" title="嵌套子测试"></a>嵌套子测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func TestMath(t *testing.T) &#123;</span><br><span class="line">// 一级子测试</span><br><span class="line">t.Run(&quot;Addition&quot;, func(t *testing.T) &#123;</span><br><span class="line">if Add(1, 2) != 3 &#123;</span><br><span class="line">t.Error(&quot;Addition failed&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 二级子测试</span><br><span class="line">t.Run(&quot;Multiplication&quot;, func(t *testing.T) &#123;</span><br><span class="line">t.Run(&quot;Positive numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if 2*3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for positive numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">t.Run(&quot;Negative numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if -2*-3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for negative numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="帮助函数"><a href="#帮助函数" class="headerlink" title="帮助函数"></a>帮助函数</h1><p>Go 的 testing 包提供了一个特殊的函数 t.Helper()，可以用来标记一个函数是测试的帮助函数，从而在测试失败时，错误信息中忽略这个帮助函数的调用栈，直接指向调用帮助函数的实际测试函数。</p><p><strong>无帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    if result := Add(2, 3); result != 5 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(2, 3) = %d; want 5&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(0, 0); result != 0 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(0, 0) = %d; want 0&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(-1, -1); result != -2 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(-1, -1) = %d; want -2&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>含有帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func checkAdd(t *testing.T, a, b, expected int) &#123;</span><br><span class="line">    t.Helper() // 标记为帮助函数</span><br><span class="line">    if result := Add(a, b); result != expected &#123;</span><br><span class="line">        t.Errorf(&quot;Add(%d, %d) = %d; want %d&quot;, a, b, result, expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    //复用，更简洁高效</span><br><span class="line">    checkAdd(t, 2, 3, 5)</span><br><span class="line">    checkAdd(t, 0, 0, 0)</span><br><span class="line">    checkAdd(t, -1, -1, -2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="setup和teardown"><a href="#setup和teardown" class="headerlink" title="setup和teardown"></a>setup和teardown</h1><p>在 Go 的测试中，Setup 和 Teardown 是两个常见的概念，用于在测试开始之前执行初始化工作（Setup），以及在测试结束之后进行清理工作（Teardown）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func setup() &#123;</span><br><span class="line">fmt.Println(&quot;Before all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func teardown() &#123;</span><br><span class="line">fmt.Println(&quot;After all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test1(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test2(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestMain(m *testing.M) &#123;</span><br><span class="line">setup()</span><br><span class="line">code := m.Run()</span><br><span class="line">teardown()</span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>集中控制测试环境：<br>TestMain 允许在单个位置控制测试的初始化和清理逻辑，而无需在每个测试中手动处理。</li><li>确保环境一致性：<br>使用 setup 和 teardown 可以确保所有测试运行在一个受控的环境中，避免因测试环境问题导致的不一致结果。</li><li>可扩展性：<br>如果需要增加更多的全局操作（如日志记录或配置加载），可以很方便地在 setup 和 teardown 中添加。</li></ul><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>Go 中的基准测试（Benchmarking）用于评估代码的性能，帮助开发者了解程序在执行时的效率和优化空间。与常规的单元测试不同，基准测试主要关注执行时间和性能瓶颈的定位，通过 testing 包中的 testing.B 类型来实现。testing.B 提供了一些方法和属性，可以用于测量函数的执行时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 被测试的函数</span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基准测试函数</span><br><span class="line">func BenchmarkAdd(b *testing.B) &#123;</span><br><span class="line">// 基准测试循环</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BenchmarkAdd 是基准测试函数。基准测试函数必须以 Benchmark 开头，并接收一个 *testing.B 类型的参数。</li><li>b.N 是基准测试的循环次数。testing.B 会根据需要调整这个值，以确保测试的执行时间足够长，能准确地测量性能。</li><li>b.N 会自动增长，确保函数执行足够多次，以消除偶然的波动。</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\code2024\go<span class="literal">-practice</span>&gt; go test <span class="literal">-bench</span> .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go<span class="literal">-practice</span></span><br><span class="line">cpu: Intel(<span class="built_in">R</span>) Core(TM) i7<span class="literal">-1065G7</span> CPU <span class="selector-tag">@</span> <span class="number">1.30</span>GHz</span><br><span class="line">Benchmark<span class="built_in">Add-8</span>          <span class="number">1000000000</span>               <span class="number">0.3078</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go<span class="literal">-practice</span>     <span class="number">0.829</span>s</span><br></pre></td></tr></table></figure><p>如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkHello(b *testing.B) &#123;</span><br><span class="line">    ... // 耗时操作</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-并发编程</title>
      <link href="/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前从未接触过并发编程的童鞋可放心食用！  </p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><ul><li>并发 (Concurrency)：<br>并发是指同时处理多个任务的能力，但这些任务不一定是同时执行的。任务可能通过切换来共享时间片。  </li><li>并行 (Parallelism)：<br>并行是指多个任务同时执行，需要多个处理器核心支持。在 Go 中，Goroutine 是通过调度器来实现并发，最终通过 CPU 核心实现并行。</li></ul><p>并发和并行的关系：<br>并发是逻辑上的任务切换，而并行是物理上的任务同时运行。</p><h1 id="Go的并发核心：Goroutine"><a href="#Go的并发核心：Goroutine" class="headerlink" title="Go的并发核心：Goroutine"></a>Go的并发核心：Goroutine</h1><h2 id="Goroutine是什么"><a href="#Goroutine是什么" class="headerlink" title="Goroutine是什么"></a>Goroutine是什么</h2><p>Goroutine 是 Go 的协程实现，是一种比传统线程更轻量级的并发任务单元。</p><ul><li>轻量：一个 Goroutine 启动时仅占用大约 2 KB 的内存（相比线程，通常占用 1 MB 堆栈）。  </li><li>调度灵活：由 Go 的运行时（runtime）管理调度，而不是直接依赖操作系统内核线程。  </li><li>高效：Go 的运行时会动态调整 Goroutine 的栈大小（最小 2 KB，最大可达 1 GB），并通过用户态线程池实现调度。  </li></ul><p>协程 vs 线程：  </p><ul><li>线程：由操作系统调度，重量级，开销较大（如栈内存固定且较大、上下文切换代价高）。  </li><li>协程：由语言运行时调度，轻量级，开销小（动态栈、用户态上下文切换）。</li></ul><h2 id="创建和使用-Goroutine"><a href="#创建和使用-Goroutine" class="headerlink" title="创建和使用 Goroutine"></a>创建和使用 Goroutine</h2><p>创建一个 Goroutine 的方法非常简单，使用 go 关键字即可。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Task is running&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> task() <span class="comment">// 启动一个 Goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Main function&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 确保主 Goroutine 不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>运行结果（顺序不可预测，Task is running可能都不会输出）：</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main function</span><br><span class="line">Task is running</span><br></pre></td></tr></table></figure><ul><li>go task()：启动一个新的 Goroutine，运行 task 函数。</li><li>主 Goroutine 继续执行 fmt.Println(“Main function”)。</li><li>如果没有 time.Sleep，主 Goroutine 会立即退出，程序结束，task 可能尚未完成。 </li></ul><h2 id="Goroutine的生命周期"><a href="#Goroutine的生命周期" class="headerlink" title="Goroutine的生命周期"></a>Goroutine的生命周期</h2><p>(1) 启动 Goroutine  </p><ul><li>Goroutine 是通过 go 关键字启动的。</li><li>每个 Goroutine 都会独立执行其任务，但与其他 Goroutine 和主 Goroutine 共享相同的地址空间。  </li></ul><p>(2) 运行中</p><ul><li>Goroutine 的调度由 Go 运行时管理，运行时会将多个 Goroutine 映射到少量的系统线程（M:N 模型）。</li><li>Goroutine 的执行顺序不确定，由运行时的调度算法决定。  </li></ul><p>(3) 结束</p><ul><li>Goroutine 执行完成或返回时会自动退出，无需显式销毁。</li></ul><h1 id="Goroutine-之间的同步与通信工具"><a href="#Goroutine-之间的同步与通信工具" class="headerlink" title="Goroutine 之间的同步与通信工具"></a>Goroutine 之间的同步与通信工具</h1><h2 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h2><p>sync 提供了一组基础的同步原语，用于解决 Goroutine 之间的同步问题，确保共享数据在多 Goroutine 环境下安全访问。</p><h3 id="常见的-sync-工具"><a href="#常见的-sync-工具" class="headerlink" title="常见的 sync 工具"></a>常见的 sync 工具</h3><p> <em>(1) sync.WaitGroup</em><br> 作用：等待一组 Goroutine 完成。<br> WaitGroup 提供了三个方法：</p><ul><li>Add(delta int)：设置需要等待的 Goroutine 数量（+delta）。</li><li>Done()：每当一个 Goroutine 完成任务，调用一次，表示减少一个需要等待的任务（-1）。</li><li>Wait()：阻塞主 Goroutine，直到所有计数归零。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// 减少计数</span></span><br><span class="line">    <span class="comment">//defer保证这句话总是在worker函数结束的时候执行，控制进程减1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line"><span class="comment">// 模拟工作任务</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数</span></span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 阻塞，直到所有任务完成</span></span><br><span class="line">fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>注：Goroutines 是按照 for 循环的顺序启动的（1, 2, 3）。这意味着 Goroutines 被创建时的顺序是确定的。实际执行顺序取决于 Go 运行时调度器，调度器会决定哪个 Goroutine 先运行。</em></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Channel 是 Go 语言中用于 在 Goroutines 之间传递数据的核心机制之一。它是 Go 中并发编程的一个重要特性，可以让不同的 Goroutines 安全地通信和同步。Channel 是一种类型化的管道，可以用于在多个 Goroutines 之间传递消息，且无需使用锁（mutex）来保证同步。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><em>声明与初始化</em>：<br>使用 make 函数创建一个 channel，并可以指定容量（缓冲区大小）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Type是通道的数据类型</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Type  <span class="comment">// 声明一个空的 channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 创建一个 channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 声明并初始化一个 channel</span></span><br><span class="line"><span class="comment">//Type 是通过 channel 传递的数据类型，表示你希望在 channel 中传递的数据类型。</span></span><br></pre></td></tr></table></figure><br><em>发送数据&amp;接收数据</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- data  <span class="comment">// 将数据发送到 channel</span></span><br><span class="line">data := &lt;-ch  <span class="comment">// 从 channel 接收数据并赋值给变量</span></span><br></pre></td></tr></table></figure><br><em>关闭 Channel</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)  <span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="comment">//使用 close(ch) 来关闭一个 channel，表示没有更多的数据会发送到该 channel。</span></span><br><span class="line"><span class="comment">//close 主要用于通知接收方，数据传输已经结束，接收方可以在接收数据时检查 channel 是否已关闭。</span></span><br></pre></td></tr></table></figure></p><p><em>通道方向</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通道：传送带</span></span><br><span class="line"><span class="comment">//只读：只能从传送带拿走东西</span></span><br><span class="line"><span class="comment">//只写：只能把东西放到传送带上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onre</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">//只读，读出来</span></span><br><span class="line">Gol := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> Gol == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onwr</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">//只写，写进去</span></span><br><span class="line">ch &lt;- <span class="number">30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅的超时处理"><a href="#优雅的超时处理" class="headerlink" title="优雅的超时处理"></a>优雅的超时处理</h3><p>凭借通道和select可以轻松完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优雅的超时处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-c1:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲区与非缓冲区"><a href="#缓冲区与非缓冲区" class="headerlink" title="缓冲区与非缓冲区"></a>缓冲区与非缓冲区</h3><ul><li>非缓冲 channel：<br>发送方和接收方必须同时准备好，才能完成数据传递。发送方在发送数据时会阻塞，直到有接收方准备好接收数据。  </li><li>缓冲 channel：<br>可以预设一个缓冲区大小，在发送数据时，若缓冲区未满，发送方不会阻塞。只有当缓冲区满时，发送方才会被阻塞。接收方也不会立即阻塞，直到缓冲区为空时</li></ul><p><strong>非缓冲channel示例</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)  <span class="comment">// 创建一个非缓冲 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 Goroutine 发送数据</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;Hello, Go!&quot;</span>  <span class="comment">// 发送数据到 channel</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据并输出</span></span><br><span class="line">    message := &lt;-ch  <span class="comment">// 从 channel 接收数据</span></span><br><span class="line">    fmt.Println(message)  <span class="comment">// 输出接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>主 Goroutine 会阻塞在 message := &lt;-ch 直到接收到来自其他 Goroutine 的数据。</li><li>ch &lt;- “Hello, Go!” 会将数据发送到 channel，并且发送操作会阻塞，直到主 Goroutine 执行完 &lt;-ch 来接收数据。</li></ul><p><strong>缓冲channel示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 2)  // 创建一个缓冲区大小为 2 的 channel</span><br><span class="line"></span><br><span class="line">    // 启动一个 Goroutine 发送数据</span><br><span class="line">    go func() &#123;</span><br><span class="line">        ch &lt;- &quot;Message 1&quot;</span><br><span class="line">        ch &lt;- &quot;Message 2&quot;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // 接收并输出数据</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>创建了一个缓冲区大小为 2 的 channel，因此可以在没有阻塞的情况下向 channel 发送 2 条消息。</li><li>当我们从 channel 中接收数据时，如果缓冲区不为空，就能顺利获取到数据。</li><li>若发送3条消息，则会阻塞，直到缓冲区被释放</li></ul><h3 id="Channel-的同步与-Goroutines-协作"><a href="#Channel-的同步与-Goroutines-协作" class="headerlink" title="Channel 的同步与 Goroutines 协作"></a>Channel 的同步与 Goroutines 协作</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)  <span class="comment">// 模拟任务执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">    ch &lt;- <span class="literal">true</span>  <span class="comment">// 通知任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">3</span>)  <span class="comment">// 创建一个缓冲区大小为 3 的 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i, ch)  <span class="comment">// 启动多个 Goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有 Goroutine 完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        &lt;-ch  <span class="comment">// 从 channel 接收任务完成的信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里使用了一个 缓冲 channel 来通知主 Goroutine 每个子 Goroutine 的任务完成。每个工作 Goroutine 在完成任务后通过 ch &lt;- true 向 channel 发送信号。</li><li>主 Goroutine 在 for 循环中通过 &lt;-ch 等待所有任务的完成，直到接收到所有的完成信号。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-语言</title>
      <link href="/2024/11/25/go-%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/11/25/go-%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>语言学习来源：</p><ul><li><a href="https://gobyexample-cn.github.io/">go-by-example</a></li><li><a href="https://geektutu.com/post/quick-golang.html">极客兔兔go简明教程</a>  </li></ul><p>原来过语言是看个输入输出直接去做题（但是后面看其实没怎么学跟项目有关的），而且这赶上期末&amp;手上有抓紧的项目，换一种方法。速通一下语言，之前学过一点点go语言皮毛，本文主要记录go在语言方面我觉得有趣不同的地方。ps：下一篇涉及并发编程&amp;单元测试</p><h1 id="string-amp-rune"><a href="#string-amp-rune" class="headerlink" title="string&amp;rune"></a>string&amp;rune</h1><p>字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte（中文一般占3byte），打印时需要用 string 进行类型转换&amp;用printf格式化，否则打印的是编码值。<br>为了更方便地处理字符（尤其是 Unicode 字符），Go 提供了 rune 类型作为字符的抽象，尤其是在处理多字节字符时，例如，字符 汉 是一个 Unicode 字符，在 UTF-8 编码下占用了 3 个字节，但作为 rune 类型，它是一个单独的值，可以直接进行操作。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line">rs := []<span class="type">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, r) </span><br><span class="line">     <span class="comment">// 输出每个字符，分别是 H e l l o ,   世 界 !</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片实际上是一个描述符，包含以下三个部分：  </p><ul><li>指向底层数组的指针：切片的数据存储在底层数组中。  </li><li>长度（length）：切片当前的元素数。  </li><li>容量（capacity）：从切片起始位置到底层数组末尾的最大元素数。  </li></ul><p>多个切片可能共享同一个底层数组，如果需要独立操作，应使用 copy 创建新的切片。如果切片扩容导致底层数组更换，原切片和新切片将不再共享同一数组。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从数组创建</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  <span class="comment">// 数组</span></span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>]                 <span class="comment">// 从数组创建切片，包含索引 1 到 3 的元素</span></span><br><span class="line">fmt.Println(s)                <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)          <span class="comment">// 创建长度为 5 的切片，初始值为零值</span></span><br><span class="line">fmt.Println(s)               <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)      <span class="comment">// 创建长度为 3，容量为 5 的切片</span></span><br><span class="line">fmt.Println(s2)              <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make函数</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//type: 数据结构的类型，必须是 slice、map 或 channel。</span></span><br><span class="line"><span class="comment">//len: 数据结构的长度（对于切片和通道来说是可选参数）。</span></span><br><span class="line"><span class="comment">//cap: 数据结构的容量（仅对切片和带缓冲的通道有效，是可选参数）。</span></span><br><span class="line"><span class="comment">//如果没有显式指定容量，默认容量等于长度：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取长度，容量</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 长度: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 容量: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片  </span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sub := s[<span class="number">1</span>:<span class="number">4</span>]         <span class="comment">// 从索引 1 到索引 3（不包含 4）</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line">sub = s[:<span class="number">3</span>]           <span class="comment">// 从索引 0 到 2</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">sub = s[<span class="number">2</span>:]           <span class="comment">// 从索引 2 到末尾</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [3 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增长</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">// 增加多个元素</span></span><br><span class="line">fmt.Println(s)        <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅声明</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 声明时初始化</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Sam&quot;</span>: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line"><span class="string">&quot;Alice&quot;</span>: <span class="string">&quot;Female&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer-amp-recover"><a href="#defer-amp-recover" class="headerlink" title="defer&amp;recover"></a>defer&amp;recover</h1><p>被 defer 的函数调用会在所在函数返回前（无论是正常返回还是因 panic 提前退出）被执行。<br>函数运行时，先跑别的，然后去找并运行defer函数（<em>被 defer 的函数调用会在所在函数返回前——无论是正常返回还是因 panic 提前退出——被执行。</em>）。在defer函数内部调用recover函数，捕获恢复程序<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(index <span class="type">int</span>)</span></span> (ret <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Some error happened!&quot;</span>, r)</span><br><span class="line">ret = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">return</span> arr[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(get(<span class="number">5</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h2><p><mark>隐式接口实现    </p><p>Go 使用隐式接口实现机制，意思是你不需要显式地声明一个类型实现了某个接口。</p><p>只要一个类型提供了接口所要求的<mark>全部方法（包括方法的名字、参数、返回值类型都一致）</mark>，那么 Go 就会认为这个类型实现了该接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stu.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Person = &amp;Student&#123;</span><br><span class="line">name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(p.getName()) <span class="comment">// Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：  </p><ul><li>定义接口 Person 和两个结构体 Student 和 Worker。  </li><li>实现 getName 方法，使得 <em>Student 和 </em>Worker 都满足 Person 接口。  </li><li>在 main 函数中：<ul><li>创建一个 *Student 的实例。</li><li>将其赋值给 Person 类型变量 p。</li><li>调用 p.getName() 方法，实际执行的是 *Student.getName，返回 Tom。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
