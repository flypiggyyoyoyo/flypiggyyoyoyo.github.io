<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flypiggy&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-08-01T08:38:39.452Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>flypiggyyoyoyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis基础</title>
    <link href="http://example.com/2025/07/31/redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/07/31/redis%E5%9F%BA%E7%A1%80/</id>
    <published>2025-07-31T18:50:52.000Z</published>
    <updated>2025-08-01T08:38:39.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习redis的笔记，本文旨在基础概念的梳理、命令熟悉和使用</p></blockquote><hr><h1 id="SQL和NoSQL"><a href="#SQL和NoSQL" class="headerlink" title="SQL和NoSQL"></a>SQL和NoSQL</h1><p>redis是典型的非关系型数据库(NoSQL)</p><p>非关系型数据库特征：</p><ul><li>无需提前定义表结构</li><li>根据场景设计合适的数据结构</li><li>弱化事务一致性，如不支持复杂的join</li></ul><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ul><li>KEYS:查看符合模板的所有key,不建议在生产环境设备上使用</li><li>DEL:删除一个指定的key</li><li>EXISTS:判断key是否存在</li><li>EXPIRE:给一个key设置有效期,有效期到期时该key会被自动删除</li><li>TTL:查看一个KEY的剩余有效期</li></ul><h2 id="string命令"><a href="#string命令" class="headerlink" title="string命令"></a>string命令</h2><ul><li>SET:添加或者修改已经存在的一个String类型的键值对</li><li>GET:根据key获取String类型的value</li><li>MSET:批量添加多个String类型的键值对</li><li>MGET:根据多个key获取多个String类型的value</li><li>INCR:让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长,例如:incrby num 2 让key为num的值自增2</li><li>INCRBYFLOAT:让一个浮点类型的数字自增并指定步长</li><li>SETNX:添加一个String类型的键值对,前提是这个key不存在,否则不执行</li><li>SETEX:添加一个String类型的键值对,并且指定有效期</li></ul><h2 id="hash命令"><a href="#hash命令" class="headerlink" title="hash命令"></a>hash命令</h2><ul><li>HSET key field value:添加或者修改hash类型key的field的值</li><li>HGET key field:获取一个hash类型key的field的值</li><li>HMSET:批量添加多个hash类型key的field的值</li><li>HMGET:批量获取多个hash类型key的field的值</li><li>HGETALL:获取一个hash类型的key中的所有的field和value</li><li>HKEYS:获取一个hash类型的key中的所有的field</li><li>HVALS:获取一个hash类型的key中的所有的value</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX:添加一个hash类型的key的field值,前提是这个field不存在,否则不执行</li></ul><h2 id="list命令"><a href="#list命令" class="headerlink" title="list命令"></a>list命令</h2><ul><li>LPUSH key element…:向列表左侧插入一个或多个元素</li><li>LPOP key:移除并返回列表左侧的第一个元素,没有则返回nil</li><li>RPUSH key element…:向列表右侧插入一个或多个元素</li><li>RPOP key:移除并返回列表右侧的第一个元素</li><li>LRANGE key starend:返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP:与LPOP和RPOP类似,只不过在没有元素时等待指定时间,而不是直接返回nil</li></ul><h2 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h2><ul><li>SADD key member…:向set中添加一个或多个元素</li><li>SREM key member…:移除set中的指定元素</li><li>SCARD key:返回set中元素的个数</li><li>SISMEMBER key member:判断一个元素是否存在于set中</li><li>SMEMBERS:获取set中的所有元素</li><li>SINTER key1 key2…:求key1与key2的交集</li><li>SDIFF key1key2…:求key1与key2的差集</li><li>SUNION key1 key2..:求key1和key2的并集</li></ul><h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><ul><li>ZADD key score member:添加一个或多个元素到sortedset,如果已经存在则更新其score值</li><li>ZREMkey member:删除sortedset中的一个指定元素</li><li>ZSCORE key member:获取sorted set中的指定元素的score值</li><li>ZRANK key member:获取sorted set 中的指定元素的排名</li><li>ZCARD key:获取sorted set中的元素个数</li><li>ZCOUNT key min max:统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member:让sorted set中的指定元素自增,步长为指定的increment值</li><li>ZRANGE key min max:按照score排序后,获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max:按照score排序后,获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION:求差集、交集、并集</li></ul><h1 id="练手demo"><a href="#练手demo" class="headerlink" title="练手demo"></a>练手demo</h1><p>demo在<a href="https://github.com/flypiggyyoyoyo/BackendDevDemos/tree/main/RedisDemos/redisPracDemo">GitHub仓库</a>中</p><h2 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h2><p>redis默认的序列化器是JDK自带的，把数据转换成二进制存储，不方便，难读且占空间大，所以需要自定义序列化器</p><h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建通用的 Jackson JSON 序列化器，用于将对象转为 JSON 存储</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置key为字符串序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置value为json序列化</span></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读、写均可实现自动序列化</p><p>为了实现反序列化，JSON序列化器会将类的class类型也一起写入JSON结果中，存入redis，会带来额外的内存开销</p><p>所以为了节省内存空间，统一使用String序列化器，要求只存储String类型的key和value，当要存储Java对象的时候，手动完成序列化和反序列化</p><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flypiggyyoyoyo.redispracdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.flypiggyyoyoyo.redispracdemo.data.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStoreUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;团长&quot;</span>, <span class="number">27</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:300&quot;</span>, json);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:300&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.readValue(json2, User.class);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习redis的笔记，本文旨在基础概念的梳理、命令熟悉和使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;SQL和NoSQL&quot;&gt;&lt;a href=&quot;#SQL和NoSQL&quot; class=&quot;headerlink&quot; title=&quot;SQL和</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-HashMap浅析</title>
    <link href="http://example.com/2025/07/02/Java-HashMap%E6%B5%85%E6%9E%90/"/>
    <id>http://example.com/2025/07/02/Java-HashMap%E6%B5%85%E6%9E%90/</id>
    <published>2025-07-02T14:28:53.000Z</published>
    <updated>2025-08-01T08:38:39.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在拆解 Java <code>HashMap</code> 解决哈希冲突的机制，深入到每个步骤和设计考量。核心围绕 <strong>桶数组 (Buckets)</strong>、<strong>链表 (Chaining)</strong>、<strong>红黑树 (Treeify)</strong> 和 <strong>扩容 (Resizing)</strong> 展开</p></blockquote><hr><p><strong>核心机制深度剖析：</strong></p><ol><li><p><strong>底层结构：桶数组 (<code>Node&lt;K,V&gt;[] table</code>)</strong></p><ul><li><strong>本质：</strong> 一个固定长度的数组（初始化后长度可动态扩容），数组的每个元素称为一个 <strong>桶 (Bucket)</strong></li><li><strong>初始容量：</strong> 默认为 <code>16</code> (<code>DEFAULT_INITIAL_CAPACITY</code>)，可指定。<strong>容量总是 2 的幂次方</strong>（如 16, 32, 64…）。这是为了高效使用位运算 <code>(n - 1) &amp; hash</code> 代替取模 <code>hash % n</code></li><li><strong>桶的状态：</strong><ul><li><code>null</code>：该桶当前没有存储任何键值对</li><li><code>Node</code> 对象：该桶存储了一个键值对节点。这个 <code>Node</code> 可能是：<ul><li>一个 <strong>单节点</strong>：该桶目前只有一个键值对（理想情况）</li><li>一个 <strong>单向链表 (Singly Linked List)</strong> 的头节点：该桶有多个键值对，通过链表连接</li><li>一个 <strong>红黑树 (Red-Black Tree)</strong> 的根节点 (<code>TreeNode</code>)：该桶链表过长已转为树（JDK8+）</li></ul></li></ul></li></ul></li><li><p><strong>定位桶：哈希计算与索引 (<code>index = (n - 1) &amp; hash</code>)</strong></p><ul><li><strong>步骤：</strong><ol><li><strong>计算原始键的哈希码：</strong> <code>int h = key.hashCode()</code>。这是 <code>Object.hashCode()</code> 方法返回的值。<strong>重写 <code>equals</code> 必须重写 <code>hashCode</code> 的根源！</strong> 相等的对象 <em>必须</em> 返回相等的哈希码，否则会导致同一个逻辑对象被映射到不同桶或无法覆盖</li><li><strong>扰动函数 (JDK 8+ 优化)：</strong> <code>hash = h ^ (h &gt;&gt;&gt; 16)</code><ul><li><strong>目的：</strong> 让原始哈希码 <code>h</code> 的 <strong>高 16 位</strong> 参与到后续的低位运算中。</li><li><strong>原因：</strong> 当桶数组 <code>n</code> 较小时（如初始 16），取模掩码 <code>(n-1)</code> 的有效位很少（例如 <code>0b1111</code> 只有低 4 位）。如果多个键的哈希码只在 <strong>高位</strong> 不同，低位完全相同，那么 <code>(n-1) &amp; h</code> 的结果就会相同（造成低位冲突）。扰动将高位特征“扩散”到低位，增加了低位的变化性，<strong>显著减少了这种高位不同低位相同导致的冲突概率</strong></li></ul></li><li><strong>计算桶索引：</strong> <code>index = (table.length - 1) &amp; hash</code><ul><li>利用 <code>table.length</code> (<code>n</code>) 是 2 的幂次方，<code>n-1</code> 的二进制形式是低位连续 <code>1</code> (如 <code>16-1=15=0b1111</code>)</li><li><code>&amp;</code> 操作相当于保留 <code>hash</code> 值的低 <code>k</code> 位（<code>k = log2(n)</code>），效果等同于 <code>hash % n</code>，但效率更高（位运算 vs 除法）</li></ul></li></ol></li><li><strong>结果：</strong> 这个 <code>index</code> 决定了键值对 <code>(key, value)</code> 应该存储在哪个桶 <code>table[index]</code> 中</li></ul></li><li><p><strong>哈希冲突的发生</strong></p><ul><li><strong>定义：</strong> 当两个不同的键 <code>key1</code> 和 <code>key2</code> 满足 <code>(table.length - 1) &amp; hash1 == (table.length - 1) &amp; hash2</code> 时，它们会被定位到同一个桶索引 <code>index</code>。无论 <code>hash1</code> 和 <code>hash2</code> 是否相等（即使不等也可能映射到同一索引），它们都需要存储在同一个桶 <code>table[index]</code> 中。这就是 <strong>哈希冲突</strong></li></ul></li><li><p><strong>解决冲突：分离链接法 (Separate Chaining)</strong></p><ul><li><strong>核心思想：</strong> 允许一个桶存储多个键值对。当冲突发生时，将新的键值对添加到该桶对应的 <strong>链式数据结构</strong> 中</li><li><strong>JDK 7 及之前：纯链表 (头插法)</strong><ul><li>每个桶 <code>table[index]</code> 指向一个 <code>Entry&lt;K,V&gt;</code> 链表的头节点</li><li><strong>插入冲突元素：</strong> 新元素插入到链表 <strong>头部</strong> (头插法)。优点是插入快 (O(1))</li><li><strong>问题：</strong><ul><li><strong>并发不安全下死链：</strong> 在多线程并发扩容时，头插法可能导致环形链表，造成 <code>get</code> 操作无限循环（JDK 8 改为尾插法解决了此问题）</li><li><strong>性能退化：</strong> 链表过长时查找效率 O(n)</li></ul></li></ul></li><li><strong>JDK 8 及之后：链表 + 红黑树 (尾插法)</strong><ul><li>每个桶 <code>table[index]</code> 指向一个 <code>Node&lt;K,V&gt;</code> 链表的头节点 <strong>或</strong> 一棵 <code>TreeNode</code> 红黑树的根节点</li><li><strong>插入冲突元素 (链表阶段)：</strong><ul><li>遍历该桶对应的链表</li><li>如果找到 <code>key</code> 相等的节点（<code>p.key == key || (key != null &amp;&amp; key.equals(p.key))</code>），则更新其 <code>value</code></li><li>如果遍历完链表未找到，则创建一个新的 <code>Node</code>，并插入到链表 <strong>尾部</strong> (尾插法)</li><li><strong>插入后检查：树化条件 (treeifyBin)</strong><ul><li>检查当前链表长度 <code>binCount</code> &gt;= <code>TREEIFY_THRESHOLD</code> (默认 <strong>8</strong>)</li><li>检查桶数组总长度 <code>table.length</code> &gt;= <code>MIN_TREEIFY_CAPACITY</code> (默认 <strong>64</strong>)</li><li><strong>两个条件同时满足</strong>，则调用 <code>treeifyBin(tab, hash)</code> 方法将该链表 <strong>转换为红黑树</strong></li><li><strong>为什么需要两个条件？</strong><ul><li><code>binCount &gt;= 8</code>：表示该桶冲突严重</li><li><code>table.length &gt;= 64</code>：表示哈希表整体规模足够大。如果表很小（比如只有 16），优先考虑 <strong>扩容</strong> (resize) 来分散冲突，而不是立即树化（因为扩容可能更有效解决该桶冲突）。如果表很小但强行树化，扩容时拆树开销大</li></ul></li></ul></li></ul></li><li><strong>树化 (<code>treeifyBin</code>):</strong><ul><li>略</li></ul></li><li><strong>树的操作 (<code>putTreeVal</code>, <code>getTreeNode</code>, <code>removeTreeNode</code>):</strong><ul><li>当操作发生在树化的桶上时，调用对应树方法</li></ul></li><li><strong>退化 (Untreeify)：</strong><ul><li>在对树进行删除操作 (<code>removeTreeNode</code>) 后，会检查当前树中的节点数 <code>size</code></li><li>如果 <code>size &lt;= UNTREEIFY_THRESHOLD</code> (默认 <strong>6</strong>)，则调用 <code>untreeify</code> 方法将红黑树 <strong>转换回普通链表</strong></li><li><strong>为什么退化阈值 (6) &lt; 树化阈值 (8)？</strong> 这是为了避免在链表长度在 7-8 之间频繁增删时，发生 <strong>树化&lt;-&gt;退化</strong> 的 <strong>反复震荡 (thrashing)</strong>。设置一个 <strong>2 的缓冲区间</strong>（6-8）增加了稳定性，减少转换开销</li></ul></li></ul></li></ul></li><li><p><strong>扩容 (Resize) - 根本性减少冲突</strong></p><ul><li><strong>目的：</strong><ul><li><strong>降低负载因子 (Load Factor)：</strong> 减少单个桶的平均元素数，降低冲突概率</li><li><strong>分散冲突：</strong> 将原本冲突严重的桶中的元素重新分配到更多桶中</li><li><strong>维持 O(1) 均摊时间：</strong> 核心目标</li></ul></li><li><strong>触发条件：</strong> <code>size</code> (当前键值对总数) &gt; <code>threshold</code> (阈值)<ul><li><code>threshold = capacity * loadFactor</code></li><li>默认 <code>loadFactor = 0.75f</code> (<code>DEFAULT_LOAD_FACTOR</code>)</li><li>例如：默认初始 <code>capacity=16</code>, <code>threshold=16*0.75=12</code>。当插入第 13 个键值对时触发扩容</li></ul></li><li><strong>为什么扩容能有效解决冲突？</strong><ul><li><strong>桶数量翻倍：</strong> 大大增加了存储位置</li><li><strong>哈希空间细化：</strong> <code>(newCap - 1)</code> 比 <code>(oldCap - 1)</code> 多了一个 <code>1</code> 位（例如 <code>0b1111</code> -&gt; <code>0b11111</code>），这意味着参与决定桶索引的哈希码位数增加了，<strong>散列更均匀</strong></li><li><strong>负载因子降低：</strong> <code>size / capacity</code> 的值变小，平均每个桶的元素数减少</li></ul></li></ul></li></ol><p><strong>关键点总结与设计哲学：</strong></p><ol><li><strong>核心目标：</strong> 在空间和时间效率之间取得平衡，保证 <code>get</code> 和 <code>put</code> 操作的平均时间复杂度为 <strong>O(1)</strong></li><li><strong>解决冲突三板斧：</strong><ul><li><strong>链表 (基础)：</strong> 处理少量冲突，简单高效</li><li><strong>红黑树 (优化)：</strong> 解决极端冲突导致的性能退化 (O(n) -&gt; O(log n))，<strong>JDK 8 的重大改进</strong>。通过树化和退化阈值 (8 和 6) 避免频繁转换。</li><li><strong>扩容 (根本)：</strong> 通过增加桶数量，从根本上降低冲突概率和链表/树的长度。负载因子 (0.75) 是空间利用率和时间效率的经验折中</li></ul></li><li><strong>“Bucket” (桶)：</strong> 哈希表底层数组的槽位 (<code>table[index]</code>)，是冲突发生的物理位置</li><li><strong>“溢出桶” 的实质：</strong> 在 Java <code>HashMap</code> 的实现中，<strong>没有独立的、物理的“溢出桶”数据结构</strong>。链表和红黑树 <strong>直接挂载在冲突发生的那个桶 (<code>table[index]</code>)</strong> 上。它们 <strong>逻辑上</strong> 是该桶处理“溢出”元素（即哈希到同一个位置的后续元素）的存储结构。因此，链表或树 <strong>就是</strong> 该桶的“溢出处理机制”</li></ol><p><strong>图示流程 (JDK 8+ <code>put</code> 操作简化版)：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. 计算 key 的扰动哈希: hash = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span><br><span class="line">2. 计算桶索引: index = (table.length - 1) &amp; hash</span><br><span class="line">3. 访问桶: bucket = table[index]</span><br><span class="line">   |</span><br><span class="line">   +-- 桶为空? (bucket == null) ------------------------------------&gt; 新建 Node 直接放入桶 (table[index] = newNode)</span><br><span class="line">   |</span><br><span class="line">   +-- 桶不为空 ---------------------------------------------------+</span><br><span class="line">        |</span><br><span class="line">        +-- 桶是树? (bucket instanceof TreeNode) ------------------&gt; 调用 treeNode.putTreeVal(...)</span><br><span class="line">        |       |</span><br><span class="line">        |       +-- 树中找到 key? --------------------------------&gt; 更新 value, 返回 oldValue</span><br><span class="line">        |       |</span><br><span class="line">        |       +-- 树中未找到 key? ------------------------------&gt; 插入新 TreeNode, 检查树结构平衡</span><br><span class="line">        |               |</span><br><span class="line">        |               +-- 插入后检查树大小? (可能触发退化检查) -----&gt; (在remove时退化)</span><br><span class="line">        |</span><br><span class="line">        +-- 桶是链表? --------------------------------------------+</span><br><span class="line">                |</span><br><span class="line">                | 遍历链表 (binCount 计数):</span><br><span class="line">                |</span><br><span class="line">                +-- 找到 key 相等的节点? (p.key == key 或 key.equals(p.key)) ---&gt; 更新 value, 返回 oldValue</span><br><span class="line">                |</span><br><span class="line">                +-- 未找到且遍历结束? (p.next == null) ------------+</span><br><span class="line">                        |</span><br><span class="line">                        | 创建新 Node 插入链表尾部 (p.next = newNode)</span><br><span class="line">                        |</span><br><span class="line">                        | 增加链表长度计数: binCount++</span><br><span class="line">                        |</span><br><span class="line">                        | binCount &gt;= TREEIFY_THRESHOLD (8)? --+</span><br><span class="line">                        |   |                                 |</span><br><span class="line">                        |   Y                                 N --&gt; 结束链表插入</span><br><span class="line">                        |   |                                 |</span><br><span class="line">                        |   table.length &gt;= MIN_TREEIFY_CAPACITY (64)? --+</span><br><span class="line">                        |       |                                       |</span><br><span class="line">                        |       Y                                       N --&gt; 触发扩容 (resize()) 优先</span><br><span class="line">                        |       |                                       |</span><br><span class="line">                        |       V                                       V</span><br><span class="line">                        |   调用 treeifyBin(table, hash) 转换链表为红黑树</span><br><span class="line">                        |</span><br><span class="line">                        | 检查全局 size: size++</span><br><span class="line">                        |</span><br><span class="line">                        | size &gt; threshold? -------------------------&gt; 触发扩容 (resize())</span><br><span class="line">                        |</span><br><span class="line">                        V</span><br><span class="line">                    结束插入 (返回 null)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文旨在拆解 Java &lt;code&gt;HashMap&lt;/code&gt; 解决哈希冲突的机制，深入到每个步骤和设计考量。核心围绕 &lt;strong&gt;桶数组 (Buckets)&lt;/strong&gt;、&lt;strong&gt;链表 (Chaining)&lt;/strong&gt;、&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一致性哈希浅析</title>
    <link href="http://example.com/2025/07/02/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E6%B5%85%E6%9E%90/"/>
    <id>http://example.com/2025/07/02/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E6%B5%85%E6%9E%90/</id>
    <published>2025-07-02T10:25:29.000Z</published>
    <updated>2025-08-01T08:38:39.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文不做深层次探究，仅为记录笔者在用一致性哈希实现动态路由层的一些想法</p></blockquote><hr><h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>当用户登录时，我们需要为用户分配netty服务实例，所以我们从nacos上拉下来了服务实例列表 <em><del>实际只有一个…项目体量很小</del></em>，现在需要把用户分配到实例上</p><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>我们选用一致性哈希。首先来看为什么摒弃普通哈希</p><h2 id="普通哈希的缺点"><a href="#普通哈希的缺点" class="headerlink" title="普通哈希的缺点"></a>普通哈希的缺点</h2><p>普通哈希的计算核心是$hashCode(id)$ % $实例数n$，这就意味着，当节点增删的时候，几乎所有连接都需要被重置，性能开销太大，连接也不稳定</p><h1 id="一致性哈希实现（部分）"><a href="#一致性哈希实现（部分）" class="headerlink" title="一致性哈希实现（部分）"></a>一致性哈希实现（部分）</h1><blockquote><p>具体代码在文末</p></blockquote><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><div class="table-container"><table><thead><tr><th>变量名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><code>Nodes</code></td><td><code>TreeMap&lt;Integer, String&gt;</code></td><td>存储 “虚拟节点哈希值→物理节点 URL” 的映射。<br>TreeMap 的有序性（红黑树实现）是实现 “顺时针查找下一个节点” 的关键。</td></tr><tr><td><code>VIRTUAL_NODES</code></td><td><code>int</code></td><td>每个物理节点对应的虚拟节点数量（默认 160），用于解决物理节点分布不均导致的负载倾斜。</td></tr><tr><td><code>instances</code></td><td><code>List&lt;ServiceInstance&gt;</code></td><td>存储真实的服务实例（如 Netty 服务器实例），记录系统中当前可用的物理节点。</td></tr><tr><td><code>map</code></td><td><code>HashMap&lt;String, ServiceInstance&gt;</code></td><td>建立 “物理节点 URL→服务实例” 的映射，用于通过 URL 快速找到对应的服务实例（如获取 IP、端口）。</td></tr></tbody></table></div><h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ul><li>把整个哈希空间虚拟成环形的，首尾相接</li><li>把物理节点和虚拟节点（的url计算出来的哈希值）映射到环形空间上，每个节点对应的url都是真实的物理节点对应的url<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> instance.getUri().toString();<span class="comment">// 真实url</span></span><br><span class="line">        Nodes.put(getHash(url), url);</span><br><span class="line">        map.put(url ,instance);<span class="comment">// url映射服务实例</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(url + <span class="string">&quot;#&quot;</span> + i );</span><br><span class="line">            Nodes.put(hash, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>提供方法找到真实url<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getServer</span><span class="params">(String clientInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 计算userId的哈希值（映射到环上的一个位置）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(clientInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 关键：获取“顺时针方向的节点集合”</span></span><br><span class="line">    <span class="comment">// TreeMap的tailMap(hash)返回所有键（节点哈希值）&gt;= hash的子映射</span></span><br><span class="line">    <span class="comment">// 这等价于在环上，从hash位置开始“顺时针”往后的所有节点</span></span><br><span class="line">    SortedMap&lt;Integer,String&gt; subMap = Nodes.tailMap(hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 找“顺时针第一个节点”</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> subMap.firstKey();</span><br><span class="line">    <span class="comment">// 如果subMap为空（即hash位置往后没有节点，相当于绕到了环的末尾）</span></span><br><span class="line">    <span class="comment">// 就取整个环的第一个节点（相当于从环的起点继续顺时针找）</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">        nodeIndex = Nodes.firstKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回这个节点对应的真实URL</span></span><br><span class="line">    <span class="keyword">return</span> Nodes.get(nodeIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过url即可O(1)的找到相应的服务实例</li></ul><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flypiggyyoyoyo.im.authenticationservice.loadBalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHash</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Integer,String&gt; Nodes = <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">VIRTUAL_NODES</span> <span class="operator">=</span> <span class="number">160</span>;<span class="comment">//虚拟节点个数，用户指定，默认160</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ServiceInstance&gt; instances = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//真实物理节点集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String,ServiceInstance&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//将服务实例与url地址一一映射</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsistentHash</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.instances = instances;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> instance.getUri().toString();</span><br><span class="line">            Nodes.put(getHash(url), url);</span><br><span class="line">            map.put(url ,instance);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(url + <span class="string">&quot;#&quot;</span> + i );</span><br><span class="line">                Nodes.put(hash, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到url地址</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServer</span><span class="params">(String clientInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 计算userId的哈希值（映射到环上的一个位置）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(clientInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 关键：获取“顺时针方向的节点集合”</span></span><br><span class="line">        <span class="comment">// TreeMap的tailMap(hash)返回所有键（节点哈希值）&gt;= hash的子映射</span></span><br><span class="line">        <span class="comment">// 这等价于在环上，从hash位置开始“顺时针”往后的所有节点</span></span><br><span class="line">        SortedMap&lt;Integer,String&gt; subMap = Nodes.tailMap(hash);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 找“顺时针第一个节点”</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> subMap.firstKey();</span><br><span class="line">        <span class="comment">// 如果subMap为空（即hash位置往后没有节点，相当于绕到了环的末尾）</span></span><br><span class="line">        <span class="comment">// 就取整个环的第一个节点（相当于从环的起点继续顺时针找）</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">            nodeIndex = Nodes.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 返回这个节点对应的真实URL</span></span><br><span class="line">        <span class="keyword">return</span> Nodes.get(nodeIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHash</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">16777619</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            hash = (hash^str.charAt(i))*p;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">13</span>;</span><br><span class="line">            hash ^=hash &gt;&gt;<span class="number">7</span>;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">3</span>;</span><br><span class="line">            hash ^=hash &gt;&gt;<span class="number">17</span>;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">5</span>;</span><br><span class="line">            <span class="comment">//如果算出来的值为负数 取其绝对值</span></span><br><span class="line">            <span class="keyword">if</span>(hash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                hash = Math.abs(hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(ServiceInstance instance)</span> &#123;</span><br><span class="line">        instances.add(instance);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> instance.getUri().toString();</span><br><span class="line">        <span class="comment">// 添加物理节点和虚拟节点</span></span><br><span class="line">        Nodes.put(getHash(url), url);</span><br><span class="line">        map.put(url, instance);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(url + <span class="string">&quot;#&quot;</span> + i);</span><br><span class="line">            Nodes.put(hash, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(ServiceInstance instance)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> instance.getUri().toString();</span><br><span class="line">        instances.remove(instance);</span><br><span class="line">        map.remove(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除物理节点和对应的所有虚拟节点</span></span><br><span class="line">        Nodes.remove(getHash(url));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">            Nodes.remove(getHash(url + <span class="string">&quot;#&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文不做深层次探究，仅为记录笔者在用一致性哈希实现动态路由层的一些想法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>netty框架笔记</title>
    <link href="http://example.com/2025/05/18/netty%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2025/05/18/netty%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/</id>
    <published>2025-05-18T15:18:41.000Z</published>
    <updated>2025-08-01T08:38:39.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Netty网络编程框架学习笔记。涉及核心组件与架构设计、主从reactor模式。仅覆盖自己设计nettyserver时查询的知识。</p></blockquote><hr><h1 id="netty架构"><a href="#netty架构" class="headerlink" title="netty架构"></a>netty架构</h1><p>netty采用分层设计，从上层API到底层实现逐步抽象，核心组件分为四层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│                     引导层 (Bootstrap)                │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │  ServerBootstrap      │  │  Bootstrap          │   │</span><br><span class="line">│  │  (服务端启动引导类)    │  │  (客户端启动引导类)   │   │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">├────────────────────────────────────────────────────┤</span><br><span class="line">│                   事件处理层 (Event Handling)          │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │  ChannelPipeline      │  │  ChannelHandler     │   │</span><br><span class="line">│  │  (处理器链)            │  │  (事件处理器)        │   │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │  ChannelHandlerContext│  │ChannelInboundHandler│   │</span><br><span class="line">│  │  (处理器上下文)        │  │  (入站处理器)        │   │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │ ChannelOutboundHandler│  │  ChannelPromise     │   │</span><br><span class="line">│  │  (出站处理器)          │  │  (异步操作结果)      │   │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">├─────────────────────────────────────────────────────┤</span><br><span class="line">│                   网络通信层 (Networking)              │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │  Channel              │  │  EventLoopGroup     │   │</span><br><span class="line">│  │  (通信通道抽象)        │  │  (事件循环组)        │   │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │  EventLoop            │  │  ChannelFuture      │   │</span><br><span class="line">│  │  (单线程事件循环)      │  │  (异步操作未来结果)   │   │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │  ByteBuf              │  │  ChannelOption      │   │</span><br><span class="line">│  │  (高效字节缓冲区)      │  │  (通道配置选项)      │   │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">├─────────────────────────────────────────────────────┤</span><br><span class="line">│                      工具层 (Utilities)               │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐  │</span><br><span class="line">│  │  ReferenceCounted     │  │ ResourceLeakDetector│  │</span><br><span class="line">│  │  (引用计数接口)        │  │  (资源泄漏检测器)     │  │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘   │</span><br><span class="line">│  ┌───────────────────────┐  ┌─────────────────────┐   │</span><br><span class="line">│  │  NettyRuntime         │  │InternalThreadLocalMap│ │</span><br><span class="line">│  │  (运行时环境)          │  │  (内部线程局部变量)  │  │</span><br><span class="line">│  └───────────────────────┘  └─────────────────────┘  │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h1 id="引导层"><a href="#引导层" class="headerlink" title="引导层"></a>引导层</h1><p>负责服务端/客户端的启动配置，整合底层组件</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li>ServerBootstrap：服务端启动引导类，配置并启动服务端</li><li>Bootstrap：客户端启动引导类，配置并启动客户端</li></ul><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><ul><li>group(EventLoopGroup boss, worker)：配置主从线程组</li><li>channel(Class&lt;? extends Channel&gt; channelClass)：指定通道实现类</li><li>childHandler(ChannelHandler handler)：设置子通道的处理器链</li><li>bind(int port)：绑定端口启动服务</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">erverBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">b.group(bossGroup, workerGroup)           <span class="comment">// 配置线程模型</span></span><br><span class="line"> .channel(NioServerSocketChannel.class)   <span class="comment">// 指定NIO通道</span></span><br><span class="line"> .childHandler(<span class="keyword">new</span> <span class="title class_">MyServerInitializer</span>()); <span class="comment">// 设置处理器链</span></span><br><span class="line"></span><br><span class="line">b.bind(<span class="number">8080</span>).sync();    <span class="comment">// 绑定端口</span></span><br></pre></td></tr></table></figure><h1 id="事件处理层"><a href="#事件处理层" class="headerlink" title="事件处理层"></a>事件处理层</h1><ul><li>负责处理网络事件和数据流转，基于责任链模式。</li><li>责任链模式：将请求的发送者和处理者解耦，建立一条处理器链，让请求依次再链上传递，知道某个处理器处理它</li></ul><h2 id="核心组件-1"><a href="#核心组件-1" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li>ChannelPipeline：处理器链容器，管理多个 ChannelHandler</li><li>ChannelHandler：事件处理器接口，分为：<ul><li>ChannelInboundHandler：处理入站数据（如读取客户端消息）</li><li>ChannelOutboundHandler：处理出站数据（如向客户端发送消息）</li></ul></li><li>ChannelHandlerContext：处理器上下文，用于在链中传递事件。在自定义处理器中用于传递处理的事件</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();<span class="comment">//处理链容器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketHeartBeatHandler</span>);<span class="comment">//添加事件处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketHeartbeatHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame frame)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> frame.text();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h1><p>负责底层网络通信实现</p><h2 id="核心组件-2"><a href="#核心组件-2" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li>EventLoopGroup：线程池组，管理多个 EventLoop<ul><li>NioEventLoopGroup：基于 Java NIO 的实现</li><li>EpollEventLoopGroup：基于 Linux Epoll 的高性能实现</li></ul></li><li>EventLoop：单线程事件循环，负责处理一个或多个 Channel 的 IO 操作</li><li>Channel：网络通信通道的抽象，支持：<ul><li>NioServerSocketChannel：服务端 NIO 通道</li><li>NioSocketChannel：客户端 NIO 通道</li></ul></li><li>ByteBuf：高效的字节缓冲区，替代 Java 原生的 ByteBuffer</li></ul><h1 id="主从Reactor模式"><a href="#主从Reactor模式" class="headerlink" title="主从Reactor模式"></a>主从Reactor模式</h1><p>netty采用的主从Reactor多线程模型时高性能网络编程的核心设计，将连接管理和数据处理分离，实现高并发能力</p><ul><li>主Reactor：负责接收客户端连接<ul><li>比如Boss Group</li><li>仅负责 接收客户端的连接请求，不处理任何 IO 读写事件</li><li>每个 Boss EventLoop 对应一个 Selector，用于监听 ServerSocketChannel 的 ACCEPT 事件</li><li>接收到连接后，将客户端的 SocketChannel 分配给 Worker Group 处理</li></ul></li><li>从Reactor：负责处理已建立连接的读写操作<ul><li>比如Worker Group</li><li>负责处理 已建立连接的 SocketChannel 的 IO 读写事件（如读数据、写数据、编解码等）</li><li>每个 Worker EventLoop 对应一个 Selector，用于监听 SocketChannel 的 READ/WRITE 等事件</li></ul></li><li>主从都可以使用多线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Netty网络编程框架学习笔记。涉及核心组件与架构设计、主从reactor模式。仅覆盖自己设计nettyserver时查询的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;netty架构&quot;&gt;&lt;a href=&quot;#netty架构&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL笔记(5)行锁表锁全局锁</title>
    <link href="http://example.com/2025/05/15/MySQL%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E8%A1%8C%E9%94%81%E8%A1%A8%E9%94%81%E5%85%A8%E5%B1%80%E9%94%81/"/>
    <id>http://example.com/2025/05/15/MySQL%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E8%A1%8C%E9%94%81%E8%A1%A8%E9%94%81%E5%85%A8%E5%B1%80%E9%94%81/</id>
    <published>2025-05-15T12:06:12.000Z</published>
    <updated>2025-08-01T08:38:39.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第五讲：全局锁和表级锁"><a href="#第五讲：全局锁和表级锁" class="headerlink" title="第五讲：全局锁和表级锁"></a>第五讲：全局锁和表级锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ul><li>一种将整个数据库实例锁定的机制</li><li>会组织其他事务对数据库的读写访问</li><li>一般在逻辑备份中使用</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>在InnoDB中可以使用 mysqldump 的 —single-transaction 选项，结合 InnoDB 的 MVCC 机制实现一致性备份，无需全局锁</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p --all-databases --single-transaction &gt; backup.sql</span><br></pre></td></tr></table></figure></li><li><p>在不支持事务的引擎中</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLES <span class="keyword">WITH</span> READ LOCK;</span><br><span class="line"><span class="comment">-- 执行备份或其他需要全局一致性的操作</span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> READ_ONLY<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 执行操作</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> READ_ONLY<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>**建议使用FTWRL**</code></pre><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p><strong>读锁可兼容读锁，写锁阻塞所有锁</strong></p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>锁定粒度为整张表</li><li>在存储引擎层加锁</li><li>不仅会对表的写/读加锁，获取到锁的线程也只能对限定的表做限定的写/读操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES table_name READ<span class="operator">/</span>WRITE</span><br></pre></td></tr></table></figure><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><ul><li>在表结构发生变更时，保护表元数据（结构、权限等）</li><li>在server层</li><li>MySQL会在执行SQL语句时隐式获取队形的MDL锁，无需手动操作<ul><li>对一个表做增删改查时，加MDL读锁</li><li>对表结构变更时，加MDL写锁</li></ul></li></ul><h2 id="对热点表DDL变更的挑战"><a href="#对热点表DDL变更的挑战" class="headerlink" title="对热点表DDL变更的挑战"></a>对热点表DDL变更的挑战</h2><ul><li>热点表：数据量小但是请求频繁</li><li>DDL变更：设计库表结构修改，create/drop等</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>MDL锁阻塞：长事务持有MDL读锁，导致DDL所需的MDL写锁无法获取，造成阻塞</li><li>传统方案局限<ul><li>KILL事务：仅能暂时释放锁，但是热点表的新请求会立即持有锁，无法根治</li><li>强制阻塞DDL：一直等待直到获取锁，导致请求大量超时，影响可用性</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>NOWAIT/WAIT n（MariaDB/AliSQL 支持）</strong></p><ul><li>ALTER TABLE … NOWAIT<ul><li>立即尝试获取 MDL 写锁，若当前无法获取（存在活跃读锁），则直接报错返回，不等待</li></ul></li><li>ALTER TABLE … WAIT n<ul><li>尝试获取 MDL 写锁，最多等待n秒，若超时仍未获取锁，则报错返回。</li></ul></li></ul><h1 id="第七讲：行锁"><a href="#第七讲：行锁" class="headerlink" title="第七讲：行锁"></a>第七讲：行锁</h1><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ul><li>锁定表中单行记录</li><li>需要就加上了，<strong>等到事务结束才释放</strong></li><li>若事务中要锁多个行，把最可能影响并发度的锁往后放</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><strong>共享锁(Shared Lock, S锁)</strong></p><ul><li>就是读锁</li><li>允许并发读</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE; <span class="comment">-- 显式加S锁</span></span><br></pre></td></tr></table></figure><p><strong>排他锁（Exclusive Lock， X锁）</strong></p><ul><li>与其他任何锁互斥</li><li>INSERT、UPDATE、DELETE自动加X锁</li></ul><h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>多事务执行过程中，因争夺互斥资源而形成的循环等待链，导致事务无法继续执行，若无外部干预，则会一直阻塞下去</li></ul><p>典型场景</p><ul><li>事务 A：更新账户 1（ID=1）的余额（加排他锁 X 锁），再尝试更新账户 2（ID=2）的余额（请求 X 锁）</li><li>事务 B：更新账户 2（ID=2）的余额（加 X 锁），再尝试更新账户 1（ID=1）的余额（请求 X 锁）</li></ul><p>结果：</p><ul><li>事务 A 持有 ID=1 的 X 锁，请求 ID=2 的 X 锁（被事务 B 持有）</li><li>事务 B 持有 ID=2 的 X 锁，请求 ID=1 的 X 锁（被事务 A 持有）</li></ul><p>形成循环等待链，导致死锁。</p><h3 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h3><ul><li>直接等待到超时，超市时间可以通过参数innodb_lock_wait_timeout来设置</li><li>死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续运行</li></ul><h3 id="死锁检测问题"><a href="#死锁检测问题" class="headerlink" title="死锁检测问题"></a>死锁检测问题</h3><p><em>死锁检测会占用大量cpu资源，存在热点行会影响性能问题，cpu利用率高但事务执行少</em></p><ul><li>临时关闭死锁检测，可能会出现超时问题</li><li>在数据库服务端做并发控制，对相同行的更新，在进入引擎之前排队</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自存笔记，学习MySQL实战45讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第五讲：全局锁和表级锁&quot;&gt;&lt;a href=&quot;#第五讲：全局锁和表级锁&quot; class=&quot;headerlink&quot; title=&quot;第五讲：全局锁和表级锁&quot;&gt;</summary>
      
    
    
    
    <category term="MySQL45讲" scheme="http://example.com/categories/MySQL45%E8%AE%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL笔记</title>
    <link href="http://example.com/2025/05/14/SQL%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2025/05/14/SQL%E7%AC%94%E8%AE%B0/</id>
    <published>2025-05-14T09:07:45.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习SQL写法 &amp;&amp; 数据库一些用法 的笔记</p></blockquote><hr><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><ul><li>数据分散到多个表时，需要用表连接来关联数据</li><li>每个join操作都会生成一个中间表，根据需要去进一步操作</li></ul><p><strong>结构</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 表<span class="number">1.</span>字段, 表<span class="number">2.</span>字段</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line">[连接类型] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>共同字段 <span class="operator">=</span> 表<span class="number">2.</span>共同字段;</span><br></pre></td></tr></table></figure><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><em>只返回两表之中满足条件的记录（<strong>交集</strong>）</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id; <span class="comment">-- 可简写为 JOIN</span></span><br></pre></td></tr></table></figure><h2 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h2><p><em>返回左表（表 A）的 所有记录，右表（表 B）中匹配的记录，若右表无匹配则用 NULL 填充</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id;</span><br></pre></td></tr></table></figure><h2 id="右链接"><a href="#右链接" class="headerlink" title="右链接"></a>右链接</h2><p><em>返回右表（表 B）的 所有记录，左表（表 A）中匹配的记录，若左表无匹配则用 NULL 填充</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id;</span><br></pre></td></tr></table></figure><h2 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h2><p><em>返回两表的 所有记录，匹配的记录合并，不匹配的字段用 NULL 填充（并集）</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.user_id;</span><br></pre></td></tr></table></figure><p>MySQl不支持上面的写法，下面是替代方案</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 条件</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 条件</span><br><span class="line"><span class="keyword">WHERE</span> 表A.id <span class="keyword">IS</span> <span class="keyword">NULL</span>; <span class="comment">-- 去重左连接已包含的记录</span></span><br></pre></td></tr></table></figure><h2 id="多表联查"><a href="#多表联查" class="headerlink" title="多表联查"></a>多表联查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表A</span><br><span class="line"><span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> 表A.id <span class="operator">=</span> 表B.a_id</span><br><span class="line"><span class="keyword">JOIN</span> 表C <span class="keyword">ON</span> 表B.id <span class="operator">=</span> 表C.b_id;</span><br></pre></td></tr></table></figure><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p><code>CROSS JOIN</code>是一种用于组合两个表中所有可能的行组合的链接方式</p><ul><li>生成全部组合：如果表 A 有 m 行，表 B 有 n 行，A CROSS JOIN B 会生成 m×n 行的结果集</li><li>无关联条件：不同于 INNER JOIN 或 LEFT JOIN，CROSS JOIN 不使用 ON 子句指定连接条件</li><li>应用场景：通常用于生成所有可能的组合，如学生与科目的全排列、日期与产品的组合等</li></ul><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表 Students</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> student_id <span class="operator">|</span> student_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>          <span class="operator">|</span> Alice        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>          <span class="operator">|</span> Bob          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 科目表 Subjects</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+</span></span><br><span class="line"><span class="operator">|</span> subject_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+</span></span><br><span class="line"><span class="operator">|</span> Math         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Science      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Students </span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> Subjects;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------+--------------+--------------+</span><br><span class="line">| student_id | student_name | subject_name |</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">| 1          | Alice        | Math         |</span><br><span class="line">| 1          | Alice        | Science      |</span><br><span class="line">| 2          | Bob          | Math         |</span><br><span class="line">| 2          | Bob          | Science      |</span><br><span class="line">+------------+--------------+--------------+</span><br></pre></td></tr></table></figure></p><p>例题：<a href="https://leetcode.cn/problems/students-and-examinations/?envType=study-plan-v2&amp;envId=sql-free-50">学生们参加各科考试的次数</a></p><h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><ul><li>对一组数据进行计算返回单一结果值，只能在SELECT和HAVING中使用</li><li>除了COUNT(*)，自动忽略NULL值</li></ul><h2 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h2><ul><li>COUNT(*)：统计所有行（包括含 NULL 的行）</li><li>COUNT(列名)：统计该列中非 NULL 值的数量</li><li>COUNT(DISTINCT 列名)：统计该列中不同值的非 NULL 数量</li></ul><h2 id="SUM"><a href="#SUM" class="headerlink" title="SUM()"></a>SUM()</h2><ul><li>获取数值列的总和，忽略NULL</li></ul><h2 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h2><ul><li>数值列的平均值，忽略NULL</li></ul><h2 id="MAX-MIN"><a href="#MAX-MIN" class="headerlink" title="MAX()/MIN()"></a>MAX()/MIN()</h2><ul><li>数值列最大最小值，忽略NULL</li></ul><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><ul><li>GROUP BY 子句用于将数据按一个或多个列分成不同的组，以便对每个组分别应用聚合函数，得到每组的汇总结果</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 分组列, 聚合函数(其他列)</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组列;</span><br></pre></td></tr></table></figure><h1 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h1><h2 id="日期计算函数"><a href="#日期计算函数" class="headerlink" title="日期计算函数"></a>日期计算函数</h2><ul><li>DATE_ADD(date, INTERVAL value unit)：日期加法</li><li>DATE_SUB(date, INTERVAL value unit)：日期减法</li><li>DATEDIFF(end_date, start_date)：返回两个日期之间的天数差（end_date - start_date）</li></ul><h1 id="筛选数据的子句"><a href="#筛选数据的子句" class="headerlink" title="筛选数据的子句"></a>筛选数据的子句</h1><div class="table-container"><table><thead><tr><th><strong>子句</strong></th><th><strong>执行时机</strong></th><th><strong>作用对象</strong></th><th><strong>是否支持聚合函数</strong></th><th><strong>典型用法</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>WHERE</code></td><td>在 <code>FROM</code> 之后、<code>GROUP BY</code> 之前</td><td>原始表中的行</td><td>❌ 不支持</td><td>过滤原始数据中的行</td><td><code>SELECT * FROM Employees WHERE salary &gt; 50000;</code></td></tr><tr><td><code>ON</code></td><td>在表连接（<code>JOIN</code>）时执行</td><td>表连接的匹配条件</td><td>❌ 不支持</td><td>定义表之间的关联规则</td><td><code>LEFT JOIN Managers ON Employees.managerId = Managers.id;</code></td></tr><tr><td><code>HAVING</code></td><td>在 <code>GROUP BY</code> 之后、<code>SELECT</code> 之前</td><td>分组后的聚合结果</td><td>✅ 支持</td><td>筛选分组后的统计结果</td><td><code>SELECT dept_id, COUNT(*) AS cnt FROM Employees GROUP BY dept_id HAVING cnt &gt; 5;</code></td></tr></tbody></table></div><h2 id="关键差异总结："><a href="#关键差异总结：" class="headerlink" title="关键差异总结："></a><strong>关键差异总结</strong>：</h2><ol><li><p><strong>执行顺序</strong>：<br><code>FROM</code> → <code>ON</code>（连接时）→ <code>WHERE</code> → <code>GROUP BY</code> → <code>HAVING</code> → <code>SELECT</code> → <code>ORDER BY</code></p></li><li><p><strong>核心区别</strong>：  </p><ul><li><code>WHERE</code>：<strong>先过滤再处理</strong>，用于原始数据的行级筛</li><li><code>ON</code>：<strong>边连接边过滤</strong>，用于控制表连接的匹配规则（尤其在 <code>LEFT JOIN</code> 中保留主表行）  </li><li><code>HAVING</code>：<strong>先分组聚合再过滤</strong>，必须与 <code>GROUP BY</code> 配合使用，用于筛选聚合后的结果（如 <code>COUNT</code>、<code>SUM</code> 等）</li></ul></li><li><p><strong>特殊场景</strong>：  </p><ul><li>在 <code>LEFT JOIN</code> 中，<code>ON</code> 条件不满足时会保留主表行（对应字段为 <code>NULL</code>），而 <code>WHERE</code> 会直接排除这些行  </li><li><code>HAVING</code> 可以引用 <code>SELECT</code> 中的别名（需注意数据库兼容性），而 <code>WHERE</code> 不行</li></ul></li></ol><hr><blockquote><h1 id="数据库知识补遗"><a href="#数据库知识补遗" class="headerlink" title="数据库知识补遗"></a>数据库知识补遗</h1></blockquote><hr><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><ul><li>强制数据完整性，简化挂你先维护</li></ul><p>学生表（Students）：student_id（主键）, name, class_id<br>班级表（Classes）：class_id（主键）, class_name</p><p>这里，Students.class_id 就是外键，它引用了 Classes.class_id，确保学生所属的班级必须存在于 Classes 表中</p><ul><li>不能引用不存在的数据：例如，添加一个学生时，如果指定的 class_id 在 Classes 表中不存在，数据库会拒绝这个操作</li><li>不能随意删除关联数据：如果 Classes 表中的某个班级被学生引用，直接删除该班级会导致引用无效，数据库通常会阻止这种删除（或级联删除关联数据）</li><li>当更新 Classes.class_id 时，外键可以自动级联更新 Students.class_id（如果配置了级联更新）</li><li>当删除 Classes 中的班级时，外键可以级联删除所有关联的学生（如果配置了级联删除）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习SQL写法 &amp;amp;&amp;amp; 数据库一些用法 的笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;JOIN&quot;&gt;&lt;a href=&quot;#JOIN&quot; class=&quot;headerlink&quot; title=&quot;JOIN&quot;&gt;&lt;/a&gt;JOIN</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL笔记(4)：索引</title>
    <link href="http://example.com/2025/05/13/MySQL%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2025/05/13/MySQL%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E7%B4%A2%E5%BC%95/</id>
    <published>2025-05-13T20:55:31.000Z</published>
    <updated>2025-08-01T08:38:39.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第四讲：索引常用数据结构、B-树、索引维护"><a href="#第四讲：索引常用数据结构、B-树、索引维护" class="headerlink" title="第四讲：索引常用数据结构、B+树、索引维护"></a>第四讲：索引常用数据结构、B+树、索引维护</h1><h2 id="索引常用数据结构"><a href="#索引常用数据结构" class="headerlink" title="索引常用数据结构"></a>索引常用数据结构</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>以键值对形式存储数据</li><li>等值查询复杂度是O(1)，范围查询性能很差，因为存储位置之间无序</li><li>底层实现通常是，数组+链表/红黑树，当多个键映射到同一索引，这些键值会以链表/红黑树形式存储在该索引位置</li></ul><h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><ul><li>就是数组中元素按照某种固定顺序排序的数组</li><li>等值查询和范围查询性能都很优秀，有序可以用二分</li><li>但是更新数据很麻烦，比如中间插入一个记录就要改动后面的所有记录，只适合静态存储引擎</li></ul><h3 id="N叉树"><a href="#N叉树" class="headerlink" title="N叉树"></a>N叉树</h3><ul><li>分叉多，树高很低，访问磁盘次数很低</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><ul><li>InnoDB使用了B+树索引模型</li><li>每一个索引再InnoDB里面对应一颗B+树</li><li>非叶子节点只存索引键和指向子节点的指针，叶子节点存索引键和完整记录（主键索引）/主键值（非主键索引）</li></ul><h3 id="聚簇索引VS二级索引"><a href="#聚簇索引VS二级索引" class="headerlink" title="聚簇索引VS二级索引"></a>聚簇索引VS二级索引</h3><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>主键索引（聚簇索引）</strong></th><th><strong>非主键索引（二级索引）</strong></th></tr></thead><tbody><tr><td><strong>非叶子节点内容</strong></td><td>主键值 + 子节点指针</td><td>非主键字段值 + 子节点指针</td></tr><tr><td><strong>叶子节点内容</strong></td><td>主键值 + <strong>完整记录</strong></td><td>非主键字段值 + <strong>主键值</strong>（需回表）</td></tr><tr><td><strong>数据存储方式</strong></td><td>数据与索引聚簇存储（物理有序）</td><td>索引与数据分离（逻辑有序）</td></tr><tr><td><strong>是否需要回表</strong></td><td>否（直接获取记录）</td><td>是（通过主键二次查询）</td></tr></tbody></table></div><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><ul><li>插入新数据时，目标数据页已填满，则需要页分裂</li><li>将满页的数据按中间位置分成两部分，原页保留前半部分，后半部分申请新的数据页</li><li>原页中最大键（或中间键）提升到父节点，作为指向新页的索引键</li></ul><h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><ul><li>删除数据后，目标数据页的数据量低于阈值，且相邻页页低</li><li>当前页与相邻页的数据合并到其中一个页，释放另一个空页</li><li>删除父节点中指向被合并页的索引键，确保索引结构正确</li></ul><h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h3><ul><li>通过数据库自增机制自动生成的无业务含义的数值型主键</li><li>自增ID是严格递增的，插入时数据按主键顺序追加，不会触发页分裂</li><li>长度短，非主键索引的叶子节点需要存主键值，节省存储空间</li><li>短主键可以减少回表时的开销</li></ul><h3 id="业务字段主键"><a href="#业务字段主键" class="headerlink" title="业务字段主键"></a>业务字段主键</h3><ul><li>选择具有实际业务意义的字段作为主键</li><li>若业务key无序（如uuid），可能频繁触发页分裂，增加I/O开销</li><li>长字符串主键可能会占用更多磁盘空间</li><li>适用于kv场景<ul><li>kv场景要求仅通过键精准查询，每行数据由“唯一键”和“对应值”组成，类似字典的结构</li><li>仅有一个索引，且是唯一索引</li></ul></li></ul><h1 id="第五讲：回表、覆盖索引、最左前缀、索引下推"><a href="#第五讲：回表、覆盖索引、最左前缀、索引下推" class="headerlink" title="第五讲：回表、覆盖索引、最左前缀、索引下推"></a>第五讲：回表、覆盖索引、最左前缀、索引下推</h1><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><ul><li>正常二级索引仅存储了索引字段值和主键值</li><li>通过二级索引查询非主键列/二级索引无法覆盖查询所需的所有列，需要额外访问主键索引获取完整数据行</li><li>当使用二级索引查询数据时，需先通过二级索引找到对应的主键值，再通过主键索引（聚簇索引）查询完整数据行，这个二次查询的过程就称为 “回表”</li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><ul><li>避免回表，提升性能</li><li>一种特殊的二级索引，通过让索引本身覆盖查询所需的所有字段，从而避免回表</li><li>MySQL中通过联合索引实现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx <span class="keyword">ON</span> <span class="keyword">user</span> (name, age, address);</span><br></pre></td></tr></table></figure><p>*创建联合索引idx，包含user表中的name，age，address字段</p><h2 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h2><ul><li>基于数据库索引的有序性设计的核心规则</li><li>查询条件必须匹配联合索引中从左到右的连续字段，才能有效利用索引加速检索</li><li>所以可以根据查询频率来设计索引</li></ul><h3 id="索引设计的核心原则"><a href="#索引设计的核心原则" class="headerlink" title="索引设计的核心原则"></a>索引设计的核心原则</h3><ul><li>复用优先：若存在高频联合查询（如<code>a AND b</code>），优先创建联合索引（a，b）</li><li>为单字段高频查询单独建立索引：若单字段拆线呢频率高&amp;无法被现有联合索引覆盖，则创建单独索引</li></ul><h3 id="索引设计决策流程"><a href="#索引设计决策流程" class="headerlink" title="索引设计决策流程"></a>索引设计决策流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">是否有高频联合查询？</span><br><span class="line">   ├─ 是 → 创建联合索引（字段顺序按高频查询条件排序，最左放等值查询字段，范围查询字段放右侧）</span><br><span class="line">   │    └─ 同时存在单字段高频查询（如仅查第二个字段）？</span><br><span class="line">   │         ├─ 是 → 额外创建单字段索引（权衡字段大小和查询频率）</span><br><span class="line">   │         └─ 否 → 无需额外索引</span><br><span class="line">   └─ 否 → 是否有高频单字段查询？</span><br><span class="line">        ├─ 是 → 创建单字段索引（多个字段则多个索引，字段小优先）</span><br><span class="line">        └─ 否 → 仅在必要时为低频需求创建单字段索引（避免全表扫描）</span><br></pre></td></tr></table></figure><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><ul><li>MySQL5.6引入的查询优化技术</li><li>通过将部分查询条件从服务层下推至引擎层，在扫描索引阶段直接过滤数据，减少回表</li><li>在传统查询流程中，存储引擎只负责根据索引定位行 ID，然后将这些 ID 返回给服务层，由服务层回表读取完整数据后再应用查询条件（如age=10）</li><li>而索引下推（ICP）将原本由服务层执行的索引字段过滤条件（如 age=10），下沉到存储引擎层执行</li></ul><p><strong>对比示例</strong></p><p>假设有查询 SELECT * FROM tuser WHERE name LIKE ‘张%’ AND age=10;，且存在联合索引 (name, age)</p><ul><li>无索引下推（ICP）时：<ul><li>存储引擎扫描索引：通过 (name, age) 索引定位所有满足 name LIKE ‘张%’ 的索引项，获取对应的行 ID（假设找到 1000 条）</li><li>回表获取完整数据：将这 1000 个行 ID 全部回表，读取完整的行数据</li><li>服务层过滤剩余条件：服务层遍历这 1000 行数据，逐一检查 age=10，最终仅 100 条符合条件，丢弃其余 900 条</li></ul></li><li>有索引下推（ICP）时：<ul><li>存储引擎扫描索引并同时检查所有条件：<br>存储引擎扫描 (name, age) 索引，同时应用 name LIKE ‘张%’ 和age=10 两个条件：<ul><li>先定位 name LIKE ‘张%’ 的索引项；</li><li>对每个匹配的索引项，直接检查其 age 值是否为 10；</li><li>仅保留同时满足两个条件的索引项（假设最终筛选出 100 条）。</li></ul></li><li>仅回表符合条件的行 ID：将这 100 个行 ID 回表，读取完整数据。</li><li>服务层直接返回结果：<br>由于存储引擎已提前过滤 age=10，服务层无需再次检查，直接返回这 100 行数据。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自存笔记，学习MySQL实战45讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第四讲：索引常用数据结构、B-树、索引维护&quot;&gt;&lt;a href=&quot;#第四讲：索引常用数据结构、B-树、索引维护&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="MySQL45讲" scheme="http://example.com/categories/MySQL45%E8%AE%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL笔记(3)：事务隔离</title>
    <link href="http://example.com/2025/05/12/MySQL%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://example.com/2025/05/12/MySQL%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2025-05-12T18:33:01.000Z</published>
    <updated>2025-08-01T08:38:39.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第三讲：事务隔离"><a href="#第三讲：事务隔离" class="headerlink" title="第三讲：事务隔离"></a>第三讲：事务隔离</h1><h2 id="多事务同时执行的问题"><a href="#多事务同时执行的问题" class="headerlink" title="多事务同时执行的问题"></a>多事务同时执行的问题</h2><ul><li>脏读：某个事务读取到了修改完未提交的数据</li><li>不可重复读：同一事务，两次读取某行数据，结果不一致（针对<strong>单行数据</strong>）</li><li>幻读：同一事物，两次相同的查询，结果集不一样（符合条件的记录被<strong>新增</strong>或<strong>删除</strong></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><ul><li>一个事务还未提交时，它做的更改就可以被看见</li><li>自动实现</li><li>会出现“三读”问题</li></ul><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><ul><li>一个事务提交后，它做的更改才可被看见</li><li>mvcc实现</li><li>会出现不可重复读、幻读问题</li></ul><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><ul><li>一个事务从启动到结束，看到的数据始终一致</li><li>mvcc实现</li><li>按照SQL标准，可重复读的隔离级别仅能保证“事务内多次读取同一行数据，数据内容一致”（解决不可重复读），不能保证“结果集的行数一致”（幻读）</li><li>innoDB通过mvcc+间隙锁解决不可重复读和幻读问题</li></ul><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><ul><li>对每一行数据，读操作加读锁，写操作加写锁，当读写锁冲突时，后访问的事务必须等待前一个事务结束才能继续执行</li><li>加锁实现</li><li>不出问题</li></ul><h2 id="隔离的实现——MVCC"><a href="#隔离的实现——MVCC" class="headerlink" title="隔离的实现——MVCC"></a>隔离的实现——MVCC</h2><ul><li>多版本并发控制</li><li>通过为数据行维护多个版本，让读操作可以不加锁的访问历史数据，避免读写冲突</li></ul><h3 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h3><p><strong>核心思路：留存数据的历史记录</strong></p><p>假设有一张学生成绩表，某行数据为<code>张三，数学，90分</code>  </p><p>当数据被修改时，比如改到85分，<strong>不直接覆盖数据</strong>，而是：  </p><ul><li>把旧数据存在“历史版本”（undolog）</li><li>新数据写在当前版本，并记录“谁改的”（事务id），这样数据有了多个版本：旧版本（90分，事务1改的）、新版本（85，事务二改的）</li></ul><p><strong>读数据时：根据 “时间线” 决定看哪个版本</strong></p><p>每个事务启动时，就像拿到一个 “时间戳”（事务 ID，比如 100、200、300，递增的）</p><p>读数据时，数据库会生成一个 “快照”（Read View），记录两件事：</p><ul><li>当前有哪些事务还没提交（比如事务 200、300 在运行中）</li><li>我自己的事务 ID 是多少（比如 100）</li></ul><p><strong>然后按规则判断：</strong></p><ul><li>如果旧版本的事务 ID 比我早（比如 100 之前的 99），说明这个版本在我启动前就提交了，我能看到它（旧数据有效）</li><li>如果新版本的事务 ID 比我晚（比如 200、300），说明这个版本是我启动后才改的，而且对应的事务还没提交，我看不到它（只能看到旧数据）</li><li>如果新版本的事务 ID 和我同时存在（比如我是 100，它是 150 但没提交），它还没写完，我也看不到，只能看旧数据。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MVCC通过“多版本数据+读视图”实现无锁读技术，核心是让读操作访问历史版本而非实时数据，从而在保证事务隔离性的同时提升并发能力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自存笔记，学习MySQL实战45讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第三讲：事务隔离&quot;&gt;&lt;a href=&quot;#第三讲：事务隔离&quot; class=&quot;headerlink&quot; title=&quot;第三讲：事务隔离&quot;&gt;&lt;/a&gt;第三讲：事</summary>
      
    
    
    
    <category term="MySQL45讲" scheme="http://example.com/categories/MySQL45%E8%AE%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL笔记(2)：一条SQL更新的执行</title>
    <link href="http://example.com/2025/05/07/MySQL%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2025/05/07/MySQL%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E7%9A%84%E6%89%A7%E8%A1%8C/</id>
    <published>2025-05-07T23:19:15.000Z</published>
    <updated>2025-08-01T08:38:39.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第二讲：一条SQL更新语句是如何执行的"><a href="#第二讲：一条SQL更新语句是如何执行的" class="headerlink" title="第二讲：一条SQL更新语句是如何执行的"></a>第二讲：一条SQL更新语句是如何执行的</h1><blockquote><p>查询语句需要走的流程，更新语句也同样需要，比如连接器验证链接身份、解析器解析词法语法等，唯一不同在于执行器执行的时候，特殊的<strong>更新操作</strong>。而这个操作又涉及到两个日志：redolog（重做）和binlog（归档）</p></blockquote><h2 id="如果更新操作不借助日志？"><a href="#如果更新操作不借助日志？" class="headerlink" title="如果更新操作不借助日志？"></a>如果更新操作不借助日志？</h2><ul><li>方案一：每次更新直接写入磁盘，这样每次更新都对应一次磁盘io，成本过高</li><li>方案二：每次修改把脏页暂存在内存里，然后延迟异步刷盘（保证性能）。但如果系统突然崩溃，内存中的脏页会丢失，此时无法保证事务的持久性</li></ul><p><em>脏页：内存中已经被修改但还没被刷新到磁盘上的数据库页面</em></p><p>显然，这两种方法都是有缺陷的，既要保证性能，又要保证持久性，就引入了<strong>WAL</strong>技术，也就是<strong>Write-Ahead Logging</strong>，关键点是先写日志，再写磁盘，这个日志就是<strong>redolog</strong></p><h2 id="RedoLog日志"><a href="#RedoLog日志" class="headerlink" title="RedoLog日志"></a>RedoLog日志</h2><ul><li>InnoDB引入的一块磁盘区域，在事务提交时，把日志写入这块磁盘区域，记录下对数据页的物理修改</li><li>这样一来，即使数据库发生异常重启，也可以凭借RedoLog来找回脏页数据，这个能力叫<strong>crash-safe</strong></li><li>RedoLog是固定大小的文件，以循环的方式写入，不断覆盖最早的内容</li></ul><h2 id="binlog日志"><a href="#binlog日志" class="headerlink" title="binlog日志"></a>binlog日志</h2><p>MySQL整体来看有两块，Server层用来实现MySQL大部分功能，存储引擎层用来存储数据。RedoLog是InnoDB引擎独有的日志。Server层也有自己的日志，叫binlog（归档日志）</p><ul><li>binlog是记录所有<strong>数据库表结构变更</strong>和<strong>表数据修改</strong>的二进制日志</li><li>由Server层实现，所有引擎都可以使用</li><li>binlog是可以追加写入的，当binlog文件写到一定大小后会切换下一个，并不会覆盖以前的日志</li></ul><h3 id="执行update语句的内部流程"><a href="#执行update语句的内部流程" class="headerlink" title="执行update语句的内部流程"></a>执行update语句的内部流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ul><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>指的是把redolog的写入分成了两个步骤，prepare和commit，这就是两阶段提交。</p><p><strong>记住，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</strong></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>定期全量备份的周期，在什么场景下，一天一备会比一周一备更有优势？</p><ul><li>数据更新频繁的系统，如电商、银行</li><li>数据一致性要求高的系统，如证券交易系统</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自存笔记，学习MySQL实战45讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第二讲：一条SQL更新语句是如何执行的&quot;&gt;&lt;a href=&quot;#第二讲：一条SQL更新语句是如何执行的&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="MySQL45讲" scheme="http://example.com/categories/MySQL45%E8%AE%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL笔记(1)：一条SQL查询的执行</title>
    <link href="http://example.com/2025/05/06/MySQL%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2025/05/06/MySQL%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/</id>
    <published>2025-05-06T16:55:59.000Z</published>
    <updated>2025-08-01T08:38:39.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自存笔记，学习MySQL实战45讲</p></blockquote><hr><h1 id="第一讲：一条SQL查询语句是如何执行的"><a href="#第一讲：一条SQL查询语句是如何执行的" class="headerlink" title="第一讲：一条SQL查询语句是如何执行的"></a>第一讲：一条SQL查询语句是如何执行的</h1><h2 id="MySQL架构理解"><a href="#MySQL架构理解" class="headerlink" title="MySQL架构理解"></a>MySQL架构理解</h2><p>首先我们知道，MySQL是分为Server层和存储引擎层两部分的。   </p><p>Server层里有连接器、查询缓存（MySQL8.0后被删除）、分析器、优化器、执行器等，负责构建MySQL的大部分功能；</p><p>存储引擎层采用插件式架构，可以支持不同的存储引擎，负责存储数据。通俗来讲，存储引擎层就像一个包裹，负责把存储引擎打包到一起，并向Server层提供读写接口</p><p>注意，不同的存储引擎<strong>共用一个</strong>Server层。也就是说，MySQL架构中，有一个Server层，一个存储引擎层，所有存储引擎公用一个Server层</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接命令一般这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure><p>mysql是客户端工具，用来链接服务端。当完成TCP三次握手后，开始验证用户身份，用的是输入的<strong>用户名</strong>和<strong>密码</strong></p><ul><li>若用户名或者密码错误，则报错<code>Access denied for user</code>，然后结束</li><li>若正确，则连接器会去权限表中查找用户拥有的权限。<strong>此后</strong>，这个链接中权限的判断逻辑，都<strong>依赖此时读到的权限</strong></li></ul><p>一个用户建立连接后，即时用管理员用户对这个用户权限做修改，也不会影响现存的链接，在建立新的链接才会使用新的权限设置</p><p>一个链接长时间不用会自动断开，需要重连才能执行请求。建议使用长连接，并定期断开再重连、执行 mysql_reset_connection 来重新初始化连接资源</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立之后，MySQL拿到查询请求，首先会去查询缓存看看，之前是否有执行过这条语句。之前执行过的语句+结果会以键值对形式存入内存。如果能命中key，则value会被直接返回</p><p>对更新压力大的数据库来说命中率极低，因为只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p><strong>MySQL8.0版本开始直接删掉这块功能了</strong></p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>未命中或没用查询缓存，则分析器发力了</p><p>先做<strong>词法分析</strong>，根据输入的SQL语句，识别出里面字符串是什么。把输入的“select”识别出这是一个查询语句，把输入的“ID”识别成“列ID”</p><p>根据词法分析的结果和语法规则，进行<strong>语法分析</strong>，分析输入的语句是否合法</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过分析器，MySQL知道你要做什么。再用优化器选择方案—怎么做</p><p>优化器是决定再多个索引的时候使用哪个索引，在多表关联的时候决定各个表的关联顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li><p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</p></li><li><p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</p></li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL通过分析器知道做什么，通过优化器知道怎么做，现在进入执行阶段</p><p>执行之前会先判断用户对这个表有没有执行权限</p><p>执行流程对比：</p><p>无索引情况，则全表扫描，具体流程如下：</p><ul><li>调用存储引擎接口获取表的第一行数据</li><li>检查该行数据是否满足查询条件（例如 ID = 10），如果满足则将其加入结果集；若不满足则跳过该行</li><li>继续调用存储引擎接口获取下一行数据，重复步骤 2，直到遍历完表中的所有行</li><li>最后将满足条件的所有行组成结果集返回给客户端</li></ul><p>有索引情况，利用索引来快速定位满足条件的数据，具体流程如下：</p><ul><li>通过索引结构快速定位到满足查询条件的第一行数据的位置</li><li>调用存储引擎接口获取该行数据并加入结果集</li><li>利用索引继续查找满足条件的下一行数据，重复步骤 2，直到没有满足条件的行</li><li>将满足条件的所有行组成结果集返回给客户端</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p><p>解析器阶段，解析词法的时候，没找到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自存笔记，学习MySQL实战45讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第一讲：一条SQL查询语句是如何执行的&quot;&gt;&lt;a href=&quot;#第一讲：一条SQL查询语句是如何执行的&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="MySQL45讲" scheme="http://example.com/categories/MySQL45%E8%AE%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker（一）理论知识</title>
    <link href="http://example.com/2025/04/09/Docker%EF%BC%88%E4%B8%80%EF%BC%89%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2025/04/09/Docker%EF%BC%88%E4%B8%80%EF%BC%89%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</id>
    <published>2025-04-09T20:39:27.000Z</published>
    <updated>2025-08-01T08:38:39.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直在用docker，没系统的捋一遍。这准备简历，所以重新弄一遍，本篇只涵盖使用的知识。后面会有实战部署笔记和底层技术。</p><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>流程：研发镜像（image）-&gt;上传到镜像仓库（Registry）-&gt;通过Docker引擎down下来-&gt;运行down下来的容器（container）</p><ul><li><p>Docker是一个容器引擎，用于管理容器的声明周期</p></li><li><p>容器：包含用于运行一个软件的环境（包含了目标软件运行所需的所有依赖）和需要运行的软件，镜像的实例</p></li><li><p>镜像：容器的安装包，必须先有镜像，才能运行容器</p></li><li><p>仓库：用于存放镜像，对镜像进行统一管理</p></li></ul><p>打个比方：仓库是软件商店，镜像是软件安装包，容器是安装成功后的软件</p><h3 id="Docker与虚拟机对比理解"><a href="#Docker与虚拟机对比理解" class="headerlink" title="Docker与虚拟机对比理解"></a>Docker与虚拟机对比理解</h3><p><img src="https://bu.dusays.com/2025/04/09/67f66c4503075.png" alt="对比"></p><h3 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h3><p>C/S架构：Client客户端，Server服务端</p><p><strong>Docker Client</strong></p><p>Docker客户端，向服务端发起请求，比如下载镜像，管理容器声明周期</p><p><strong>Docker Daemon</strong></p><p>Docker的后台守护程序，包含：</p><ul><li><p>Docker Server：服务端，接收请求</p></li><li><p>Engine：容器引擎，负责执行任务</p></li></ul><p><strong>Docker Registry</strong></p><p>镜像仓库</p><h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p><strong><code>docker search jdk</code></strong> 用于查找jdk镜像的版本</p><p><strong><code>docker pull openjdk:11</code></strong> 把jdk的镜像拉取到本地，冒号用于指定版本</p><p><strong><code>docker images</code></strong> 查看本地镜像</p><p><strong><code>docker rmi 123456</code></strong> 删除id号为123456的<strong>本地镜像</strong></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><strong><code>docker ps</code></strong> 查看当前运行的容器</p><p><strong><code>docker ps -a</code></strong> 查看当前所有容器名称</p><p><strong><code>docker run [容器名称]</code></strong> 运行目标名称的容器，默认前台运行</p><blockquote><p><strong>前台运行vs后台运行</strong></p><p><strong>前台运行</strong>：启动容器时，将容器的输入输出与宿主机的终端相连，用户可以直接在当前终端与容器进行交互</p><p><strong>后台运行</strong>：容器在后台独立运行，不与宿主机的终端直接关联。容器启动后，命令行会立即返回，你可以继续在宿主机终端执行其他操作</p></blockquote><p><strong><code>docker run -d -p 80:81 [容器名称]</code></strong> 运行目标名称的容器，-d指定后台运行，-p指定容器监听主机80端口，若有请求则转发到容器内81端口</p><blockquote><p>因为资源隔离，所以容器内外网络不互通，eg内外都有80port，所以用到-p参数标识路由转发</p></blockquote><p><strong><code>docker run -d -P [容器名称]</code></strong> -P 参数的作用是让 Docker 自动在宿主机上选取一个可用的端口，并将其映射到容器内暴露(<code>EXPOSE</code>)的端口上，暴露端口指的是在<code>Dockerfile</code>里通过<code>EXPOSE</code>命令声明的容器内监听的端口</p><p><strong><code>docker rm 123456</code></strong> 删除id为123456的停止的<strong>容器</strong>，id不一定为123456，只要123456能定位到一个唯一id的容器即可</p><p><strong><code>docker rm -f 123456</code></strong> 强制删除id为123456的容器，无论是否运行中</p><p><strong><code>docker stop 123456</code></strong> 停止id为123465的容器</p><p><strong><code>docker start 123456</code></strong> 启动id为123456的容器</p><p><strong><code>docker run -d -name cont01 [容器名称]</code></strong> 启动目标容器并指定名称为cont01，后续操作可用名字代替id</p><p><strong><code>docker run --rm [容器名称]</code></strong> 运行容器，<code>rm</code>标识该容器停止后会自动删除</p><p><strong><code>docker run -d --restart on-failure:3 [容器名称]</code></strong> <code>--restart</code>标识重启策略，默认不重启；<code>on-failure</code>失败时重启，可以加上<code>:3</code>表示第三次部署失败就不重启了；<code>always</code>表示只要已关闭就自动重启</p><p><strong><code>docker run -d -P -e JAVA_ENV=dev -e JAVA_VM=G1 nginx</code></strong> 启动 <code>nginx</code> 容器时设置 <code>JAVA_ENV=dev</code> 和 <code>JAVA_VM=G1</code> 这两个环境变量</p><p><strong><code>docker inspect NAME|ID</code></strong> 查看docker对象的详细信息</p><p><strong><code>docker exec -it cont01 env</code></strong> exec命令是指定cont01容器，基于容器内终端（it），来执行env命令（显示环境变量）</p><p><strong><code>-m 8m</code></strong> 限制内存最大为8mb，<strong><code>--cpus 1</code></strong> 限制cpu最多用一个</p><p><strong><code>docker logs cont01</code></strong> 输出cont01容器的所有日志</p><p><strong><code>docker exec -it cont01 bash</code></strong> 进入容器cont01内部，并使用bash</p><h1 id="Docker进阶"><a href="#Docker进阶" class="headerlink" title="Docker进阶"></a>Docker进阶</h1><h2 id="数据卷Volume"><a href="#数据卷Volume" class="headerlink" title="数据卷Volume"></a>数据卷Volume</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>是容器外部的独立存储空间，即使容器被删除，数据卷仍会保留。</p></li><li><p>同一个数据卷可被多个容器同时挂载，所有容器对卷内数据的读写操作是实时同步的</p></li><li><p>容器可通过数据卷直接访问宿主机文件系统，高性能</p></li></ul><h3 id="绑定方式"><a href="#绑定方式" class="headerlink" title="绑定方式"></a>绑定方式</h3><h4 id="匿名绑定"><a href="#匿名绑定" class="headerlink" title="匿名绑定"></a>匿名绑定</h4><p><code>docker run -v /app/data nginx</code>Docker 自动创建无名称卷，存储路径为宿主机的 <code>Docker 数据目录/volumes/随机哈希</code></p><ul><li><p>容器删除后卷仍然存在，需要手动清理</p></li><li><p>容器启动时加 <code>--rm</code>，停止后卷会自动删除</p></li></ul><h4 id="具名绑定"><a href="#具名绑定" class="headerlink" title="具名绑定"></a>具名绑定</h4><p><code>docker run -d -v my-named-volume:/app/data my-image</code> 不关心存放的位置，只想持久化存储一些内容</p><ul><li><p>有自定义的名字，能够轻松识别和管理卷</p></li><li><p>除非手动删除，否则会一直存在</p></li></ul><h4 id="Bind-Mount"><a href="#Bind-Mount" class="headerlink" title="Bind Mount"></a>Bind Mount</h4><p>把宿主机的目录直接映射到容器内的目录</p><p><code>docker run -v /host/path:/container/path my-image</code> <code>/host/path</code> 是宿主机上的路径，<code>/container/path</code> 是容器内的挂载路径</p><ul><li><p>只要宿主机上的文件或目录存在，即使容器被删除，数据也不会丢失</p></li><li><p>可以挂载宿主机上的任意文件或目录，不受 Docker 卷存储管理的限制</p></li><li><p>宿主机和容器内的文件修改会实时同步</p></li></ul><h3 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure><h2 id="网络Network"><a href="#网络Network" class="headerlink" title="网络Network"></a>网络Network</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>是<code>Docker</code>对容器网络隔离的一项技术，提供了多种不同模式供用户使用，选择不同的网络模式来实现<strong>容器网络</strong>的互通以及的隔离</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul><li><p>容器间的网络隔离</p></li><li><p>实现部分容器之间的网络隔离</p></li><li><p>管理多个子网下的容器ip</p></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><p>提供了多种模式，可以定制化的为每个容器制定不同的网络</p></li><li><p>自定义网络模式，划分不同的子网|网关|dns等配置</p></li><li><p>实现网络互通</p><ul><li><p>实现不同子网之间的网络互通</p></li><li><p>基于容器名（主机名）的方式在网络内访问</p></li></ul></li></ul><h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><h4 id="bridge桥接模式（默认模式）"><a href="#bridge桥接模式（默认模式）" class="headerlink" title="bridge桥接模式（默认模式）"></a>bridge桥接模式（默认模式）</h4><p>在主机中创建一个<code>Docker0</code>的网桥，在<code>Docker0</code>创建一对虚拟网卡，有一半在主机上<code>vethxxx</code>，有一半在容器内<code>eth0</code></p><p><img src="https://bu.dusays.com/2025/04/09/67f66db2967ed.png" alt="bridgeMode"></p><h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>容器不再拥有自己的网络空间，而是直接与主机共享网络空间，基于该模式创建的容器对应的ip实际及时与主机为同一个子网，同一个网段</p><p><img src="https://bu.dusays.com/2025/04/09/67f66bd6546e7.png" alt="hostMode"></p><h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p><code>Docker</code>会拥有自己的网络空间，不与主机共享，在这个网络模式下的容器，不会被分配网卡&amp;ip&amp;路由等相关信息</p><ul><li><p>完全隔离，与外部任何机器都无网络访问，只与自己的io，本地网络127.0.0.1</p></li><li><p>绝对安全</p></li></ul><p><img src="https://bu.dusays.com/2025/04/09/67f66bd665669.png" alt="noneMode"></p><h4 id="Container模式"><a href="#Container模式" class="headerlink" title="Container模式"></a>Container模式</h4><p>不会创建自己的网络，与其他容器共享网络空间，直接使用指定容器的ip/端口</p><p><img src="https://bu.dusays.com/2025/04/09/67f66bd65e8c2.png" alt="containerMode"></p><h4 id="自定义网络模式（推荐）"><a href="#自定义网络模式（推荐）" class="headerlink" title="自定义网络模式（推荐）"></a>自定义网络模式（推荐）</h4><p>不适用<code>Docker</code>自带的网络模式，而是自己定制化自己持有的网络模式</p><p>命令：<code>docker network COMMOND</code></p><pre><code>Manage networksCommands:  connect     Connect a container to  a network  create      Create a network  disconnect  Disconnect a container from a network  inspect     Display detailed information on one or more networks  ls          List networks  prune       Remove all unused networks  rm          Remove one or more networks</code></pre><p><strong>为什么自定义网路中的容器能通过容器名ping通，但是bridge模式不行</strong></p><p>在<code>Docker</code>自定义网络中，<code>DNS</code>被深度集成以实现容器间的自动服务发现。当容器加入自定义网络时，<code>Docker</code>会将其容器名和<code>ip</code>地址注册到<code>DNS</code>服务器</p><p>bridge模式不嵌入DNS</p><h3 id="不同模式下的链接"><a href="#不同模式下的链接" class="headerlink" title="不同模式下的链接"></a>不同模式下的链接</h3><p><code>docker network connect wolfcode net1</code></p><p><img src="https://bu.dusays.com/2025/04/09/67f66bd6681e6.png" alt="contactBetweenTwoDifferentMode"></p><h2 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><ul><li><p><strong>构建镜像</strong>用的</p></li><li><p><code>Docker</code>为我们提供的一个用于自定义构建镜像的一个配置文件：描述如何构建一个对象</p></li><li><p>利用<code>Docker</code>提供的<code>build</code>命令，指定<code>Dockerfile</code>文件，就可以按照配置的内容将镜像构建出来</p></li></ul><h4 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h4><ul><li><p>作为开发者，需要将自己开发好的项目打包成<code>Docker</code>镜像，便于后面直接作为<code>Docker</code>容器运行</p></li><li><p>作为运维人员，需要构建更精简的基础设施服务镜像，满足公司的需求以及尽可能减少冗余的功能占用过多的资源</p></li></ul><h4 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h4><ul><li><p>可以自定义镜像内容</p></li><li><p>构建公共基础镜像减少其他镜像配置</p></li><li><p>开源程序快速部署</p></li><li><p>实现企业内容项目快速交付</p></li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><strong><code>FROM</code></strong></p><p>指定以什么镜像为基础镜像，在改进项的基础之上构建新的镜像</p><p>如果不想以任何镜像为基础：<code>FROM scratch</code></p><p>语法：</p><ul><li><p><code>FROM &lt;image&gt;</code></p></li><li><p><code>FROM &lt;image&gt;:&lt;tag&gt;</code></p></li><li><p><code>FRom &lt;image&gt;:&lt;digest&gt;</code></p></li></ul><p>以上三种写法，后两者为指定具体版本，第一种则使用<code>latest</code>也就是最新版</p><p><strong><code>MAINTAINER</code></strong></p><p>指定镜像的维护者</p><pre><code>MAINTAINER John Doe &lt;johndoe@example.com&gt; </code></pre><p><code>MAINTAINER</code> 指令指定了镜像的维护者是 John Doe，其邮箱为 <code>johndoe@example.com</code></p><p><em>Docker官方现已弃用MAINTAINER命令，他的功能可以用LABEL指令更灵活的实现</em></p><p><strong><code>LABEL</code></strong></p><p>为镜像|容器|卷添加元数据</p><p>语法</p><ul><li><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li></ul><p>可以在一条 <code>LABEL</code> 指令中定义多个键值对，也能使用多条 <code>LABEL</code> 指令。键值对之间用空格分隔，键和值之间用等号连接</p><p>eg</p><pre><code>LABEL maintainer=&quot;John Doe &lt;johndoe@example.com&gt;&quot;</code></pre><p><strong><code>ENV</code></strong></p><p>设置容器的环境变量，可以设置多个</p><p>语法：</p><ul><li><p><code>ENV &lt;key&gt; &lt;value&gt;</code></p></li><li><p><code>ENV &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...</code></p></li></ul><p><strong><code>RUN</code></strong></p><p><code>RUN</code> 指令在<strong>构建镜像</strong>期间执行，在 Dockerfile 中可以有多个 <code>RUN</code> 指令，每个 <code>RUN</code> 指令都会在镜像中创建一个新的层。为了减少镜像的层数和体积，建议将相关的命令组合在一个 <code>RUN</code> 指令中执行</p><p>语法：</p><ul><li><p><code>RUN &lt;command&gt;</code></p></li><li><p><code>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></p></li></ul><p>第一种写法直接写<code>shell</code>脚本即可</p><p>第二种写法类似于函数调用，第一个参数为可执行文件，后面的都是参数</p><p>eg</p><pre><code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></pre><p><code>-c</code> 后面跟着的 <code>&quot;echo hello&quot;</code> 会被当作 shell 命令来执行，所以直接调用 <code>/bin/bash</code> 来执行 <code>echo hello</code> 命令</p><p><strong><code>ADD</code></strong></p><p>复制命令，把<code>src</code>的文件复制到镜像的<code>dest</code>位置（从主机复制到容器）</p><p>语法：</p><ul><li><p><code>ADD &lt;src&gt; &lt;dest&gt;</code></p></li><li><p><code>ADD [&quot;&lt;src&gt;&quot;,&quot;&lt;dest&gt;&quot;</code></p></li></ul><p><strong><code>WORKDIR</code></strong></p><p>设置并<code>cd</code>到容器中的工作目录，如果该目录不存在则自动创建。</p><p>语法：</p><ul><li><code>WORKDIR /app</code></li></ul><p>在根目录下创建<code>app</code>目录</p><p><strong><code>VOLUME</code></strong></p><p>设置挂载目录，可以将主机中的指定目录挂载到容器中</p><p>语法：</p><ul><li><p><code>VOLUME [&quot;&lt;dir&gt;&quot;]</code></p></li><li><p><code>VOLUME &lt;dir&gt;</code></p></li><li><p><code>VOLUME &lt;dir&gt; &lt;dir&gt;</code></p></li></ul><p><strong><code>EXPOSE</code></strong></p><p>设置容器启动后要暴露的端口（容器在运行时会监听的网络端口）</p><p>语法：</p><ul><li><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt; ...]</code></li></ul><p><code>&lt;port&gt;</code>表示容器要监听的端口号,<code>&lt;protocol&gt;</code>是可选参数，用于指定端口使用的协议，默认值为 <code>tcp</code>，也可以设置为 <code>udp</code></p><p><em>注意：<code>EXPOSE</code>只是暴露端口，并没有与主机的端口形成映射。映射行为是在容器<code>run</code>的时候加<code>-p</code>参数实现的</em></p><p><strong><code>CMD</code></strong></p><p><code>CMD</code> 指令在<strong>容器</strong>启动时执行，在 Dockerfile 中只能有一个 <code>CMD</code> 指令，若有多个 <code>CMD</code> 指令，只有最后一个会生效</p><p>语法：</p><ul><li><p><code>CMD echo &quot;Hello world!&quot;</code></p></li><li><p><code>CMD [&quot;echo&quot;,&quot;Hello world!&quot;]</code></p></li></ul><p><strong><code>ENTRYPOINT</code></strong></p><p>用来设置容器启动时要执行的命令，并且这个命令不能被 <code>docker run</code> 后面的参数直接覆盖，它提供了一种固定容器启动行为的方式，常用于设置容器的主命令</p><p><strong><code>CMD</code>和<code>ENTRYPOINT</code>的区别</strong></p><ul><li><p>单独使用 <code>ENTRYPOINT</code>，<code>docker run</code> 后面添加的参数会被当作 <code>ENTRYPOINT</code> 命令的参数</p></li><li><p>单独使用 <code>CMD</code>，如果 <code>docker run</code> 后面添加了其他命令，<code>CMD</code> 指定的命令会被覆盖</p></li><li><p>当 <code>ENTRYPOINT</code> 和 <code>CMD</code> 结合使用时，<code>CMD</code> 提供的参数会作为 <code>ENTRYPOINT</code> 命令的默认参数，若 <code>docker run</code> 后面添加了参数，这些参数会替换 <code>CMD</code> 的默认参数</p></li></ul><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>基于一个现有的容器，构建一个新的镜像（image）</p><p><em>定制化操作不方便！</em></p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p><del>自己构建两个镜像练练手</del></p><p>eg</p><pre><code># 使用Python 3.9作为基础镜像FROM python:3.9-slim# 设置工作目录WORKDIR /app# 复制当前目录下的所有文件到工作目录COPY . /app# 安装应用所需的依赖RUN pip install --no-cache-dir -r requirements.txt# 暴露应用运行的端口EXPOSE 5000# 设置环境变量ENV FLASK_APP=app.pyENV FLASK_RUN_HOST=0.0.0.0# 定义容器启动时执行的命令CMD [&quot;flask&quot;, &quot;run&quot;]</code></pre><h2 id="仓库Registry"><a href="#仓库Registry" class="headerlink" title="仓库Registry"></a>仓库Registry</h2><ul><li><p>用于管理<code>Docker</code>的镜像</p></li><li><p>快速交付</p></li><li><p>便于镜像的重复利用</p></li></ul><p><img src="https://bu.dusays.com/2025/04/09/67f670340b283.png" alt="registry"></p><h3 id="常见仓库"><a href="#常见仓库" class="headerlink" title="常见仓库"></a>常见仓库</h3><ul><li><p><code>Docker Hub</code></p></li><li><p><code>Aliyun</code></p></li><li><p><code>Nexus</code></p></li><li><p><code>Harbor</code></p></li></ul><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p><strong>这块没啥理论上的，实际部署一下就会了</strong></p><p>针对容器声明周期的管理，对容器声明周期进行更快速方便的方式进行管理</p><ul><li><p>依赖管理，当一个容器必须在另一个容器运行完成后才能运行时，就需要进行依赖管理</p></li><li><p>副本数控制，容器有时候也需要集群，快速对容器集群进行弹性伸缩</p></li><li><p>配置共享，通过配置文件统一描述需要运行的服务相关信息，自动化的解析配置内容，并构建对应服务</p></li></ul><p><em>更简单的使用容器</em></p><h3 id="Docker-Compose-单机"><a href="#Docker-Compose-单机" class="headerlink" title="Docker Compose(单机)"></a>Docker Compose(单机)</h3><ul><li><p>基于构建好的镜像来<strong>创建和管理多个容器</strong></p></li><li><p>需求：在一台机器上部署多个容器</p></li><li><p><code>Docker-Compose</code>可以高效便捷的管理单机上运行的所有容器，通过<code>yaml</code>配置文件的方式完成之前执行<code>docker run</code>命令所设置的所有参数。</p></li></ul><p><img src="https://bu.dusays.com/2025/04/09/67f66bd6631c0.png" alt="dockerCompose"></p><h4 id="服务services"><a href="#服务services" class="headerlink" title="服务services"></a>服务services</h4><p>需要运行的容器配置，可以理解为原先用<code>docker run</code>命令后面跟的一系列配置信息，都配在这里面</p><h4 id="网络networks"><a href="#网络networks" class="headerlink" title="网络networks"></a>网络networks</h4><p><code>docker-compose</code>公共自定义网络管理，配置好以后，可以直接在<code>services</code>中引用该网络配置，这个配置可以多个<code>services</code>使用</p><h4 id="数据卷volums"><a href="#数据卷volums" class="headerlink" title="数据卷volums"></a>数据卷volums</h4><p><code>docker-compose</code>下的统一数据卷管理，可以给多个<code>services</code>使用</p><h3 id="Swarm-分布式"><a href="#Swarm-分布式" class="headerlink" title="Swarm(分布式)"></a>Swarm(分布式)</h3><p>做<code>docker</code>的公司写的，与<code>k8s</code>竞争</p><h2 id="Portainer可视化工具"><a href="#Portainer可视化工具" class="headerlink" title="Portainer可视化工具"></a>Portainer可视化工具</h2><p><strong>很推荐啊，天天只在命令行docker来docker去，快docker抑郁了</strong></p><pre><code>PS C:\Users\flypiggy&gt; docker --versionDocker version 28.0.1, build 068a01ePS C:\Users\flypiggy&gt; docker volume create portainer_dataportainer_dataPS C:\Users\flypiggy&gt; docker run -d -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ceUnable to find image &#39;portainer/portainer-ce:latest&#39; locallylatest: Pulling from portainer/portainer-cee2e06b27b87e: Pull complete1fed1531b45b: Pull complete04de093ad5ed: Pull complete86a7cce72d42: Pull completee09df2601140: Pull completeeae3ebf29ea8: Pull completec12aa3fbd31a: Pull completef111bda3f9a6: Pull complete81021110ed01: Pull complete4f4fb700ef54: Pull completeDigest: sha256:7f10a26bfdda3fc58295ea09b860117ecd86a642d66fb94ce1f27a4c221d4649Status: Downloaded newer image for portainer/portainer-ce:latest61cbab51c68ba3134921a2d7beb1ce320716682cac10f2094c0f08f3ae01c4d8</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一直在用docker，没系统的捋一遍。这准备简历，所以重新弄一遍，本篇只涵盖使用的知识。后面会有实战部署笔记和底层技术。&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="云原生" scheme="http://example.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>go有意思的特性</title>
    <link href="http://example.com/2025/01/24/go%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2025/01/24/go%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%89%B9%E6%80%A7/</id>
    <published>2025-01-24T09:46:32.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<p>如题，记录一些自认为有趣的特性</p><p><strong>定时器</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器1执行完毕，协程定时器2终止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">&lt;-timer1.C</span><br><span class="line">fmt.Println(<span class="string">&quot;timer1 is done&quot;</span>)</span><br><span class="line"></span><br><span class="line">timer2 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开一个协程，此时程序一边运行协程func，一边跑下面的stop，因为timer2会立即stop，所以不会打印timer2 is done</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-timer2.C</span><br><span class="line">fmt.Println(<span class="string">&quot;timer2 is done&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">stop := timer2.Stop()</span><br><span class="line"><span class="keyword">if</span> stop &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;timer2 is stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打点器</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打点器700ms一次，程序等待3s，输出working</span></span><br><span class="line"><span class="comment">//有一个通道用来通知协程关闭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建打点器实例，后面需要释放这个实例</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">700</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//协程开始，用for循环不断得到打点器的值，输出ticker now</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">fmt.Println(<span class="string">&quot;Tick at&quot;</span>, t)</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">ticker.Stop() <span class="comment">//打点器停止</span></span><br><span class="line">ch &lt;- <span class="literal">true</span>    <span class="comment">//协程停止</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ticker stopped&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="image.png" alt="alt text"></p><p><strong>时间限制</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//速度限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">////七个任务，300ms一个，无处理爆发任务能力</span></span><br><span class="line"><span class="comment">//tick := time.Tick(300 * time.Millisecond) //打点器，ticker需要先实例且课手动停止，tick直接运行到程序结束</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//re := make(chan int, 7)</span></span><br><span class="line"><span class="comment">//for i := 1; i &lt;= 7; i++ &#123;</span></span><br><span class="line"><span class="comment">//re &lt;- i</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//close(re)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//for r := range re &#123;</span></span><br><span class="line"><span class="comment">//&lt;-tick</span></span><br><span class="line"><span class="comment">//fmt.Println(&quot;time &quot;, r, time.Now())</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//七个任务，300ms一个，可处理4个爆发任务（并发）</span></span><br><span class="line"><span class="comment">//能处理四个爆发任务，即存有四个时间令牌</span></span><br><span class="line">conti := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">conti &lt;- time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//开一个协程，隔300ms发送一个时间令牌表示可以处理事件+1</span></span><br><span class="line"><span class="comment">//通道conti容量是4</span></span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> time.Tick(<span class="number">300</span> * time.Millisecond) &#123;</span><br><span class="line">conti &lt;- t</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟任务</span></span><br><span class="line">requt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">requt &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(requt)</span><br><span class="line"><span class="comment">//任务处理，前四个在通道里已经有时间令牌了，很迅速的完成，后面三个保持300ms左右完成一个</span></span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> requt &#123;</span><br><span class="line">&lt;-conti</span><br><span class="line">fmt.Println(r, <span class="string">&quot; is done&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原子计数器</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子计数器，20个协程，每个累加50次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ops <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">50</span>; j++ &#123;</span><br><span class="line">atomic.AddUint64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//直接到地址处加1，所以多协程不会出错</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(ops)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>互斥锁</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line"><span class="comment">//aa叠加500+500次，bb叠加400次</span></span><br><span class="line"><span class="comment">//结构体里互斥锁，结构体方法：锁上，执行动作，解锁</span></span><br><span class="line"><span class="comment">//WaitGrounp保证协程</span></span><br><span class="line"><span class="comment">//单独函数执行累加</span></span><br><span class="line"><span class="comment">//使用WaitGrounp的时候，每个协程完毕后要运行wg.Done通知wg.WaitGroup任务结束，否则会一直被wg.Wait阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counti <span class="keyword">struct</span> &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">contner <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counti)</span></span> inc(name <span class="type">string</span>) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.contner[name] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := Counti&#123;</span><br><span class="line">contner: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;aa&quot;</span>: <span class="number">0</span>, <span class="string">&quot;bb&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wg := sync.WaitGroup&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">prog := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c.inc(name)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">go</span> prog(<span class="string">&quot;aa&quot;</span>, <span class="number">500</span>)</span><br><span class="line"><span class="keyword">go</span> prog(<span class="string">&quot;aa&quot;</span>, <span class="number">500</span>)</span><br><span class="line"><span class="keyword">go</span> prog(<span class="string">&quot;bb&quot;</span>, <span class="number">400</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(c.contner)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>panic&amp;revocer&amp;defer</strong></p><p>程序执行过程中遇到显式的panic会立即开始回溯调用栈，只有 defer 语句能在这个回溯过程中被执行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 defer 语句，在其中调用 recover 尝试捕获 panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 若 recover 返回值不为 nil，说明成功捕获到 panic</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;捕获到 panic:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;任务开始执行&quot;</span>)</span><br><span class="line">    <span class="comment">// 触发 panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;执行任务时出现严重错误&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;这行代码不会被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序开始&quot;</span>)</span><br><span class="line">    performTask()</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序继续执行，未崩溃&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间戳</strong></p><p>时间戳是一个表示特定时间点的单一数值，通常是从某个固定的起始时间（纪元）开始计算，到指定时间点所经过的时间量。在 Unix 系统中，纪元是 1970 年 1 月 1 日 00:00:00 UTC，常见的时间戳单位有秒、毫秒、微秒、纳秒等。例如，1672531200 这个秒级时间戳代表的是从 1970 年 1 月 1 日 00:00:00 UTC 到 2023 年 1 月 1 日 00:00:00 UTC 所经过的秒数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    now := time.Now()<span class="comment">//当下时间</span></span><br><span class="line">    secs := now.Unix()<span class="comment">//从纪年(到当下时间所经历的秒数</span></span><br><span class="line">    nanos := now.UnixNano()<span class="comment">//纳秒数量</span></span><br><span class="line">    fmt.Println(now)</span><br><span class="line"></span><br><span class="line">    millis := nanos / <span class="number">1000000</span></span><br><span class="line">    fmt.Println(secs)</span><br><span class="line">    fmt.Println(millis)</span><br><span class="line">    fmt.Println(nanos)</span><br><span class="line"></span><br><span class="line">    fmt.Println(time.Unix(secs, <span class="number">0</span>))</span><br><span class="line">    fmt.Println(time.Unix(<span class="number">0</span>, nanos))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个指定的时间对象</span></span><br><span class="line">    specifiedTime, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2024-10-01 12:00:00&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;时间解析错误:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定时间的秒级时间戳</span></span><br><span class="line">    timestamp := specifiedTime.Unix()</span><br><span class="line">    fmt.Println(<span class="string">&quot;指定时间的秒级时间戳:&quot;</span>, timestamp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如题，记录一些自认为有趣的特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定时器&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;</summary>
      
    
    
    
    <category term="Go学习" scheme="http://example.com/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go爬虫————页面抓取</title>
    <link href="http://example.com/2024/12/17/go%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E6%8A%93%E5%8F%96/"/>
    <id>http://example.com/2024/12/17/go%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E6%8A%93%E5%8F%96/</id>
    <published>2024-12-17T17:29:07.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>跟着<a href="https://github.com/CocaineCong">小生凡一</a>老师做的，目的是熟悉网络的请求与响应&amp;数据库<br>从17号晚上开始敲了两三个点马马虎虎敲完了，不到200行，中间连接数据库，import等等耽误时间了，先复习一遍，然后找个静态网站抓一下  </p><p>不管代码有多少行，一个爬虫的核心流程通常是：<br> <strong>发送请求</strong> → <strong>获取响应</strong> → <strong>解析数据</strong> → <strong>保存结果</strong><br>所以接下来也按照这个步骤来过一遍两个项目</p><p>代码开源在了<a href="https://github.com/QUSTflypiggy/go-proj-self">go-proj-self</a></p><hr><h1 id="（一）抓取豆瓣top250"><a href="#（一）抓取豆瓣top250" class="headerlink" title="（一）抓取豆瓣top250"></a>（一）抓取豆瓣top250</h1><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><ul><li>构造客户端</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client:=http.Client</span><br></pre></td></tr></table></figure><ul><li>构造GET请求</li></ul><p><em>网页处按F12-&gt;点network-&gt;刷新-&gt;点TOP250-&gt;会有url，请求方法等</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req,err:=http.NewRequest(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;https://movie.douban.com/top250&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//请求体没有所以是nil</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">//如果出错</span></span><br><span class="line">fmt.Println(<span class="string">&quot;req err&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加请求头，伪造成浏览器请求，防止被反爬虫识别而失败</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>发送请求</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;请求失败&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()<span class="comment">//防止资源泄露</span></span><br></pre></td></tr></table></figure><h2 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h2><p>当请求成功时，可以正常获取响应</p><h2 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h2><p><strong>css选择器</strong> 在爬取静态页面的时候常用css选择器</p><ul><li>将 HTTP 响应的 Body 转换为一个可操作的 DOM 文档                                     </li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docDetail, err := goquery.NewDocumentFromReader(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;解析失败&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取节点信息<ul><li><code>Find(selector)</code>通过css选择器定位到html目标</li><li><code>Each(func(i int,s *goquery.Selection)&#123;&#125;)</code>遍历找到的所有元素，执行自定义逻辑</li></ul></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find根据css选择器找到目标html元素，each遍历元素执行自定义操作func</span></span><br><span class="line">docDetail.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).</span><br><span class="line">Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, s *goquery.Selection)</span></span> &#123; <span class="comment">//s是当前节点的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储元素，为插入数据库做准备</span></span><br><span class="line"><span class="keyword">var</span> data MovieData</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.hd &gt; a &gt; span:nth-child(1)&quot;</span>).Text() <span class="comment">//提取文本内容：标题</span></span><br><span class="line"></span><br><span class="line">img := s.Find(<span class="string">&quot;div &gt; div.pic &gt; a &gt; img&quot;</span>) <span class="comment">//找到img元素</span></span><br><span class="line">imgtem, ok := img.Attr(<span class="string">&quot;src&quot;</span>)            <span class="comment">//提取src</span></span><br><span class="line"></span><br><span class="line">info := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.bd &gt; p:nth-child(1)&quot;</span>).Text() <span class="comment">//简洁（导演，主演，年份）</span></span><br><span class="line"></span><br><span class="line">score := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.bd &gt; div &gt; span.rating_num&quot;</span>).Text() <span class="comment">//评分</span></span><br><span class="line">quote := s.Find(<span class="string">&quot;div &gt; div.info &gt; div.bd &gt; p.quote &gt; span&quot;</span>).Text()        <span class="comment">//引言</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">director, actor, year := InfoSpite(info) <span class="comment">//构造InfoSpite函数解析字段提取主演，导演，年份</span></span><br><span class="line"></span><br><span class="line">data.Title = title</span><br><span class="line">data.Picture = imgtem</span><br><span class="line">data.Score = score</span><br><span class="line">data.Quote = quote</span><br><span class="line"></span><br><span class="line">data.Actor = actor</span><br><span class="line">data.Director = director</span><br><span class="line">data.Year = year</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> InsertData(data) &#123; <span class="comment">//插入数据库</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;插入失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;插入成功&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDB</span><span class="params">()</span></span> &#123; <span class="comment">//初始化连接数据库</span></span><br><span class="line"><span class="comment">//path := strings.Join([]string&#123;USERNAME, &quot;:&quot;, PASSWORD, &quot;@tcp(&quot;, HOST, &quot;:&quot;, PORT, &quot;)/&quot;, DBNAME, &quot;?charset=utf8&quot;&#125;, &quot;&quot;)</span></span><br><span class="line">path := USERNAME + <span class="string">&quot;:&quot;</span> + PASSWORD + <span class="string">&quot;@tcp(&quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT + <span class="string">&quot;)/&quot;</span> + DBNAME + <span class="string">&quot;?charset=utf8&quot;</span></span><br><span class="line"></span><br><span class="line">DB, _ = sql.Open(<span class="string">&quot;mysql&quot;</span>, path) <span class="comment">//打开数据库连接</span></span><br><span class="line"><span class="comment">//设置了连接的最大存活时间为 10（单位应该是与具体实现相关，通常是秒），意味着一个数据库连接在经过 10 个单位时间后，如果还没有被使用，将会被关闭回收，这样可以避免长时间闲置的连接占用过多资源</span></span><br><span class="line">DB.SetConnMaxLifetime(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//设定了最大空闲连接数为 5，也就是数据库连接池中最多允许存在 5 个处于空闲状态的连接，当空闲连接数超过这个值时，多余的空闲连接会被关闭，有助于合理控制资源使用和提升数据库连接性能</span></span><br><span class="line">DB.SetMaxIdleConns(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 DB.Ping() 语句来测试与数据库的连接是否可用</span></span><br><span class="line"><span class="comment">//它会向数据库发送一个简单的测试请求（比如 MySQL 中类似 SELECT 1 的操作）</span></span><br><span class="line"><span class="comment">//如果连接正常且数据库可以响应，则返回 nil ，否则返回一个包含错误信息的 error 类型值。</span></span><br><span class="line"><span class="keyword">if</span> err := DB.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;opon database fail&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;connect success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertData</span><span class="params">(movieData MovieData)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用全局变量 DB 来创建一个数据库事务 tx</span></span><br><span class="line">tx, err := DB.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Begin err &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备sol语句</span></span><br><span class="line">stmt, err := tx.Prepare(<span class="string">&quot;INSERT INTO movie_data(`Title`,`Director`,`Picture`,`Actor`,`Year`,`Score`,`Quote`)VALUES(?,?,?,?,?,?,?)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Prepare err &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stmt.Exec:通过预处理语句执行插入操作，将 MovieData 结构体中的字段逐个绑定到 SQL 语句中的占位符 ?</span></span><br><span class="line">_, err = stmt.Exec(movieData.Title, movieData.Director, movieData.Picture, movieData.Actor, movieData.Year, movieData.Score, movieData.Quote)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Exec err &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务，将sql语句写入数据库</span></span><br><span class="line">_ = tx.Commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="（二）抓取静态在线图书馆"><a href="#（二）抓取静态在线图书馆" class="headerlink" title="（二）抓取静态在线图书馆"></a>（二）抓取静态在线图书馆</h1><p><a href="http://books.toscrape.com/?">在线图书馆连接</a><br>跟上一个差不多，主要自己敲一遍，熟悉一下过程，有几个小点在这里列一下</p><ul><li>小星星图标转换成string</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scoreClass, exists := s.Find(<span class="string">&quot;article &gt; p&quot;</span>).Attr(<span class="string">&quot;class&quot;</span>)</span><br><span class="line">score := <span class="string">&quot;Unknown&quot;</span></span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line"><span class="comment">// scoreClass 可能是 &quot;star-rating Three&quot; 或类似字符串</span></span><br><span class="line">scoreParts := strings.Split(scoreClass, <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(scoreParts) &gt; <span class="number">1</span> &#123;</span><br><span class="line">score = scoreParts[<span class="number">1</span>] <span class="comment">// 提取 &quot;Three&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将评分转换为数字存储</span></span><br><span class="line">rating := <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> score &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;One&quot;</span>:</span><br><span class="line">rating = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Two&quot;</span>:</span><br><span class="line">rating = <span class="number">2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Three&quot;</span>:</span><br><span class="line">rating = <span class="number">3</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Four&quot;</span>:</span><br><span class="line">rating = <span class="number">4</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Five&quot;</span>:</span><br><span class="line">rating = <span class="number">5</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">rating = <span class="number">0</span> <span class="comment">// 如果没有匹配到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文字追踪到去掉空格和换行符</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rawStatus := s.Find(<span class="string">&quot;article &gt; div.product_price &gt; p.instock.availability&quot;</span>).Text()</span><br><span class="line">status := strings.TrimSpace(rawStatus) <span class="comment">// 去掉前后的空格和换行符</span></span><br></pre></td></tr></table></figure><h1 id="（三）动态网页"><a href="#（三）动态网页" class="headerlink" title="（三）动态网页"></a>（三）动态网页</h1><p><em>2024/12/19更新一下</em></p><p>爬的是b站评论，不同点在要先找到评论的接口api，然后把json格式转为struct存起来，再序列化出来用，代码开源在了github上<br>其余解析，存取没有什么不同，就没写完</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;碎碎念&quot;&gt;&lt;a href=&quot;#碎碎念&quot; class=&quot;headerlink&quot; title=&quot;碎碎念&quot;&gt;&lt;/a&gt;碎碎念&lt;/h1&gt;&lt;p&gt;跟着&lt;a href=&quot;https://github.com/CocaineCong&quot;&gt;小生凡一&lt;/a&gt;老师做的，目的是熟悉网络的请求</summary>
      
    
    
    
    <category term="go实战项目" scheme="http://example.com/categories/go%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>go-Gin简明教程</title>
    <link href="http://example.com/2024/12/04/go-Gin%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/12/04/go-Gin%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</id>
    <published>2024-12-04T19:45:05.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习来源<a href="https://geektutu.com/post/quick-go-gin.html">极客兔兔Gin简明教程</a>&amp;<a href="https://chatgpt.com/">ChatGPT</a></p><p>（老师的文章已经很全了）。本文是作为一个纯小白在学习兔老师教程的时候一些思考和资料查询。<br>需要先安装go和gin，这里建议直接看老师的教程，很细。  </p><h1 id="Gin是什么"><a href="#Gin是什么" class="headerlink" title="Gin是什么"></a>Gin是什么</h1><p>Gin 是一个用 Go 语言编写的轻量级、高性能的 Web 框架，因其简洁的设计和极高的处理性能，在开发 RESTful API 和 Web 服务时非常流行</p><p><strong>Gin 的特点</strong></p><ul><li>轻量级  <ul><li>代码量少，启动速度快，适合构建微服务。</li><li>没有包含过多的插件，保持核心简单，用户可以按需扩展。</li></ul></li><li>高性能<ul><li>Gin 使用 Go 的 net/http 标准库作为底层，性能表现极为优越。</li><li>使用 Radix 树 和 字符串查找优化 实现路由匹配，高效解析 HTTP 请求。</li></ul></li><li>中间件机制<ul><li>提供了中间件支持，用户可以灵活定义和扩展功能，例如日志、认证、错误处理等。</li></ul></li><li>开发友好<ul><li>提供了简洁的 API 和丰富的功能，如路由分组、参数绑定、JSON 数据处理等。</li><li>对于错误处理和调试有专门支持，如 Context 对象方便统一处理请求数据和响应。</li></ul></li></ul><h1 id="快速上手一个Gin程序"><a href="#快速上手一个Gin程序" class="headerlink" title="快速上手一个Gin程序"></a>快速上手一个Gin程序</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writen by geektutu</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="comment">//导入 gin 包，该包提供了构建 Web 应用所需的所有功能。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;Hello, Geektutu&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建Gin实例"><a href="#创建Gin实例" class="headerlink" title="创建Gin实例"></a>创建Gin实例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br></pre></td></tr></table></figure><p><code>gin.Default()</code>:</p><ul><li>返回一个 Gin 引擎实例，用于管理路由和中间件。</li><li>默认情况下，包含两个中间件：<ul><li>Logger：记录请求日志。</li><li>Recovery：自动处理程序中的崩溃并返回 500 错误。</li></ul></li></ul><h2 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;Hello, Geektutu&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="分段讲解"><a href="#分段讲解" class="headerlink" title="分段讲解"></a>分段讲解</h3><ul><li><code>r.GET(&quot;/&quot;)</code><ul><li>定义了一个HTTP GET方法的路由，路径为根路径/</li><li>告诉Gin什么样的URL（<a href="http://localhost:8080/）">http://localhost:8080/）</a> </li></ul></li><li><code>func(c *gin.Context)&#123;&#125;</code><ul><li>定义了一个匿名函数作为请求处理器</li><li><code>c</code>是一个<code>*gin.Context</code>的对象，封装了 HTTP 请求和响应的相关信息。（后文会细讲，这里作用是返回我们想要在浏览器上显示的信息）</li></ul></li><li><code>c.String(200, &quot;Hello, Geektutu&quot;)</code><ul><li>使用<code>c.String</code>方法向客户端返回纯文本相应</li><li><code>200</code>是HTTP状态码，表示请求成功</li></ul></li></ul><h2 id="启动web服务器"><a href="#启动web服务器" class="headerlink" title="启动web服务器"></a>启动web服务器</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br></pre></td></tr></table></figure><ul><li>用 r.Run()函数来让应用运行在本地服务器上，默认监听端口是 8080，可以传入参数设置端口，例如r.Run(“:9999”)即运行在 9999端口。</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">&quot;debug&quot;</span> mode. Switch to <span class="string">&quot;release&quot;</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using <span class="built_in">env</span>:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to <span class="built_in">set</span> a value.</span><br><span class="line">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies <span class="keyword">for</span> details.</span><br><span class="line">[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure><p><strong>浏览器访问 <a href="http://localhost:8080">http://localhost:8080</a></strong></p><p><img src="image.png" alt="alt text"></p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在 Gin 中，路由（Router）是处理 HTTP 请求并根据请求的不同路径和方法（如 GET、POST）来调用特定的处理函数（handler）的核心机制。Gin 路由通过 *gin.Engine 实例来管理和匹配这些请求。我们可以定义不同的路径和方法，并为每个请求指定对应的处理逻辑。</p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><ul><li><strong>GET</strong>：处理 GET 请求（从服务器获取数据）。</li><li>POST：处理 POST 请求（向服务器提交数据）。</li><li>PUT：处理 PUT 请求（更新服务器上的数据）。</li><li>DELETE：处理 DELETE 请求（删除服务器上的数据）。</li><li>PATCH：处理 PATCH 请求（局部更新资源）。</li></ul><h2 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;Who are you?&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="解析路径参数"><a href="#解析路径参数" class="headerlink" title="解析路径参数"></a>解析路径参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;Hello %s&quot;</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主要代码解释"><a href="#主要代码解释" class="headerlink" title="主要代码解释"></a>主要代码解释</h3><ul><li><code>r.GET(&quot;/user/:name&quot;, ...)</code><ul><li>r.GET 定义了一个 GET 请求 的路由。</li><li>“/user/:name” 中的 :name 是一个 动态路径参数。这意味着，name 不是一个固定的值，而是从请求的 URL 中动态提取的部分。</li><li>例如，URL <a href="http://localhost:8080/user/flypiggy">http://localhost:8080/user/flypiggy</a> 会使 name 变成 flypiggy。任何符合 /user/{name} 格式的请求都会匹配这个路由，并将 {name} 作为参数传递给处理函数。</li></ul></li><li><code>name := c.Param(&quot;name&quot;)</code><ul><li>c.Param(“name”) 从请求的 URL 中提取名为 name 的路径参数。</li><li>假设你访问的 URL 是 <a href="http://localhost:9999/user/flypiggy">http://localhost:9999/user/flypiggy</a>  ，c.Param(“name”) 会获取到 “flypiggy” 这个值，并将其赋值给变量 name。</li></ul></li><li><code>http.Statusok</code><ul><li>就是HTTP状态码200，表示请求成功</li></ul></li></ul><h2 id="获取Query参数"><a href="#获取Query参数" class="headerlink" title="获取Query参数"></a>获取Query参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">role := c.DefaultQuery(<span class="string">&quot;role&quot;</span>, <span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;%s is a %s&quot;</span>, name, role)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>name := c.Query(&quot;name&quot;)</code><ul><li>c.Query(“name”) 是从 URL 查询字符串中提取名为 name 的参数。</li><li>若没有name，则返回空字符串</li><li>查询字符串<ul><li>是 URL 中用来传递参数的一部分，通常位于 URL 的路径后面，紧跟着 ? 符号。它由一系列键值对组成，多个键值对之间通过 &amp; 符号分隔。</li><li><code>http://example.com/path?key1=value1&amp;key2=value2</code>，?后面就是查询字符串</li></ul></li></ul></li><li><code>role := c.DefaultQuery(&quot;role&quot;,&quot;teacher)</code><ul><li>从URL查询字符串中提取名为role的参数</li><li>若没有role，则默认值为teacher</li></ul></li></ul><h2 id="获取POST参数"><a href="#获取POST参数" class="headerlink" title="获取POST参数"></a>获取POST参数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/form&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password := c.DefaultPostForm(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;000000&quot;</span>)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul><li><code>r.POST(&quot;/form&quot;, ...)</code><ul><li>r.POST 定义了一个 POST 请求 的路由。</li><li>路由的路径是 “/form”，这意味着它会匹配对 <a href="http://localhost:8080/form">http://localhost:8080/form</a> 的 POST 请求。</li></ul></li><li><code>username := c.PostForm(&quot;username&quot;)</code><ul><li>c.PostForm(“username”) 用来获取 POST 请求中的表单数据中名为 username 的参数。</li><li>假设客户端发送的请求体中包含 username=geektutu，那么 c.PostForm(“username”) 的值将是 “geektutu”。</li><li>如果请求中没有该参数，则返回空字符串。</li></ul></li><li><code>password := c.DefaultPostForm(&quot;password&quot;, &quot;000000&quot;)</code><ul><li>c.DefaultPostForm(“password”, “000000”) 用来获取 POST 请求中的表单数据中名为 password 的参数。如果没有该参数，则使用默认值 “000000”。</li></ul></li><li><code>c.JSON(http.StatusOK, gin.H&#123;...&#125;)</code><ul><li>c.JSON 用来返回一个 JSON 响应，http.StatusOK 表示 HTTP 状态码 200，表示请求成功。</li><li>gin.H 是 Gin 提供的一个便捷方法，用于创建一个键值对（map）。在这个例子中，返回的 JSON 包含 username 和 password 两个字段，分别对应从 POST 请求中获取的参数值。</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>浏览器地址栏无法直接构造 POST 请求。</li><li>推荐使用命令行的 cURL 或工具（如 Postman）来发送复杂的 POST 请求。</li><li>如果一定要用浏览器，最简单的方法是创造HTMl表单，这里不细说</li></ul><h2 id="Map参数（字典参数）"><a href="#Map参数（字典参数）" class="headerlink" title="Map参数（字典参数）"></a>Map参数（字典参数）</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">ids := c.QueryMap(<span class="string">&quot;ids&quot;</span>)</span><br><span class="line">names := c.PostFormMap(<span class="string">&quot;names&quot;</span>)</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;ids&quot;</span>:   ids,</span><br><span class="line"><span class="string">&quot;names&quot;</span>: names,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>ids := c.QueryMap(&quot;ids&quot;)</code><ul><li>这是从 查询字符串 中解析一个以 <code>ids</code> 为前缀的嵌套参数，返回值是一个 <code>map[string]string</code>。</li><li>查询字符串格式类似：  <code>?ids[Jack]=001&amp;ids[Tom]=002</code><br>解析后，ids 将是：<code>map[string]string&#123;&quot;Jack&quot;: &quot;001&quot;,&quot;Tom&quot;: &quot;002&quot;,&#125;</code></li></ul></li><li><code>names := c.PostFormMap(&quot;name&quot;)</code><ul><li>这是从 表单数据 中解析一个以 <code>names</code> 为前缀的嵌套参数，返回值是一个<code>map[string]string</code></li><li>表单数据格式类似：<code>names[a]=Sam&amp;names[b]=David</code>,解析后，names 将是：<code>map[string]string&#123;&quot;a&quot;: &quot;Sam&quot;,&quot;b&quot;: &quot;David&quot;,&#125;</code></li></ul></li></ul><h2 id="重定向-Redirect"><a href="#重定向-Redirect" class="headerlink" title="重定向(Redirect)"></a>重定向(Redirect)</h2><p>在 Gin 框架中，重定向 是指服务器收到一个请求后，告诉客户端（通常是浏览器）去访问另一个 URL。这样，客户端会再次发起请求到新的 URL。</p><h3 id="重定向的类型"><a href="#重定向的类型" class="headerlink" title="重定向的类型"></a>重定向的类型</h3><h4 id="301永久重定向"><a href="#301永久重定向" class="headerlink" title="301永久重定向"></a>301永久重定向</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/old&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;/new&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>客户端访问 /old 时，服务器告诉它目标地址是 /new。</li><li>浏览器可能会缓存这个重定向，下次直接访问 /new。</li><li>浏览器缓存重定向是指浏览器在收到一个重定向响应后，将这个重定向的信息保存在缓存中，并在之后访问相同的 URL 时自动按照重定向规则跳转到目标 URL，而无需再次向服务器发送请求。</li></ul><h4 id="302临时重定向"><a href="#302临时重定向" class="headerlink" title="302临时重定向"></a>302临时重定向</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/temp&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusFound, <span class="string">&quot;/another&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>客户端访问 /temp 时，被引导到 /another。</li><li>浏览器不会缓存重定向，下次依然会访问 /temp。</li></ul><h4 id="303重定向（常用于表单提交之后）"><a href="#303重定向（常用于表单提交之后）" class="headerlink" title="303重定向（常用于表单提交之后）"></a>303重定向（常用于表单提交之后）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/submit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusSeeOther, <span class="string">&quot;/result&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>适用于表单提交后引导用户到另一个页面。</li><li>如果表单通过 POST 提交，重定向后浏览器会使用 GET 方法访问 /result。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部重定向，请求转发</span></span><br><span class="line">r.GET(<span class="string">&quot;/goindex&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Request.URL.Path = <span class="string">&quot;/&quot;</span></span><br><span class="line">r.HandleContext(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>解释：<ul><li>当用户访问 /goindex 路由时：<ul><li>将 c.Request.URL.Path 的值从 /goindex 改为 /。</li><li>使用 r.HandleContext(c) 将修改后的请求重新交给 Gin 的路由引擎处理。</li></ul></li></ul></li><li>内部重定向的作用：<ul><li>不返回 HTTP 重定向响应。这与 c.Redirect 不同，HandleContext 是将当前请求直接路由到另一个处理函数。</li><li>在此例中，最终会路由到 / 的处理函数，并返回该处理函数的结果。</li></ul></li></ul><h2 id="分组路由"><a href="#分组路由" class="headerlink" title="分组路由"></a>分组路由</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">defaultHandler := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;path&quot;</span>: c.FullPath(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// group: v1</span></span><br><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1.GET(<span class="string">&quot;/posts&quot;</span>, defaultHandler)</span><br><span class="line">v1.GET(<span class="string">&quot;/series&quot;</span>, defaultHandler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// group: v2</span></span><br><span class="line">v2 := r.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v2.GET(<span class="string">&quot;/posts&quot;</span>, defaultHandler)</span><br><span class="line">v2.GET(<span class="string">&quot;/series&quot;</span>, defaultHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要每个路由都单独加上 /api/v1 前缀。你可以通过 路由分组 来实现对路由前缀的统一管理。路由分组会为组内的所有路由自动加上一个共同的前缀，这样你只需在创建路由组时定义一次前缀，然后在组内定义具体的路由，无需重复加前缀。</p><h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h1><h2 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/upload1&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">file, _ := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// c.SaveUploadedFile(file, dst)</span></span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;%s uploaded!&quot;</span>, file.Filename)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>file, _ := c.FormFile(&quot;file&quot;)</code><ul><li>c.FormFile(“file”) 用于从 HTTP 请求的 form-data 中提取文件。”file” 是表单字段的名称，它是客户端上传文件时指定的字段名。</li><li>这行代码获取到的 file 是一个 *multipart.FileHeader 类型的对象，包含了上传文件的详细信息（如文件名、大小、类型等）。</li><li>file.Filename：上传文件的文件名。</li><li>file.Size：上传文件的大小。</li><li>file.Header：上传文件的额外信息，如文件的 MIME 类型。</li></ul></li></ul><blockquote><p>注意：c.FormFile() 返回的 file 对象是文件的元数据，并不是文件本身的数据流。如果要保存文件，可以使用 c.SaveUploadedFile() 方法。</p></blockquote><ul><li><p><code>c.String(http.StatusOK, &quot;%s uploaded!&quot;, file.Filename)</code></p><ul><li>这行代码通过 c.String 返回一个字符串响应，表示文件上传成功，并且展示上传文件的名称。</li><li>http.StatusOK 表示 HTTP 状态码 200，表示请求成功。</li><li>file.Filename 变量会替换字符串中的 %s，显示上传的文件名。</li></ul></li></ul><h2 id="多个文件"><a href="#多个文件" class="headerlink" title="多个文件"></a>多个文件</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/upload2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// Multipart form</span></span><br><span class="line">form, _ := c.MultipartForm()</span><br><span class="line">files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">log.Println(file.Filename)</span><br><span class="line"><span class="comment">// c.SaveUploadedFile(file, dst)</span></span><br><span class="line">&#125;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="渲染html模板"><a href="#渲染html模板" class="headerlink" title="渲染html模板"></a>渲染html模板</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line"><span class="comment">//这行代码告诉 Gin 加载 templates/ 目录下的所有模板文件。LoadHTMLGlob 会加载符合指定模式的文件，这里是 templates/ 文件夹中的所有文件。</span></span><br><span class="line"></span><br><span class="line">stu1 := &amp;student&#123;Name: <span class="string">&quot;Geektutu&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">stu2 := &amp;student&#123;Name: <span class="string">&quot;Jack&quot;</span>, Age: <span class="number">22</span>&#125;</span><br><span class="line">r.GET(<span class="string">&quot;/arr&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;arr.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line">        <span class="comment">//&quot;arr.tmpl&quot; 是要渲染的模板文件名，假设该文件存在于 templates/ 文件夹中。</span></span><br><span class="line">        <span class="comment">//gin.H&#123;&#125; 是 Gin 提供的一个便捷方法，表示一个 map[string]interface&#123;&#125;，用于将数据传递到模板中。在这里传递了两个字段</span></span><br><span class="line"><span class="string">&quot;title&quot;</span>:  <span class="string">&quot;Gin&quot;</span>,</span><br><span class="line"><span class="string">&quot;stuArr&quot;</span>: [<span class="number">2</span>]*student&#123;stu1, stu2&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>在 Gin 中，中间件（Middleware）是用于在请求处理过程中的“请求-响应”链条中间进行拦截和处理的函数。它通常用于执行一些通用操作，例如日志记录、认证、授权、错误处理等。中间件可以在请求到达路由处理函数之前，或者在响应返回客户端之前，执行一些特定的操作。</p><h2 id="中间件的定义"><a href="#中间件的定义" class="headerlink" title="中间件的定义"></a>中间件的定义</h2><p>Gin 中的中间件是一个函数类型，签名为</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span></span><br></pre></td></tr></table></figure><p>其中，*gin.Context 是 Gin 中的上下文对象，提供了访问请求和响应的功能。</p><h2 id="如何使用中间件"><a href="#如何使用中间件" class="headerlink" title="如何使用中间件"></a>如何使用中间件</h2><p>在 Gin 中，可以使用 <code>r.Use()</code> 来为路由或路由组添加中间件。一个应用可以有多个中间件，Gin 会按添加顺序依次执行这些中间件。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>通过 <code>r.Use()</code> 可以添加全局中间件，意味着所有路由都会经过这些中间件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 Gin 路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的中间件，记录请求的路径</span></span><br><span class="line">r.Use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Request path:&quot;</span>, c.Request.URL.Path)</span><br><span class="line">c.Next() <span class="comment">// 调用下一个中间件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由</span></span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><p>如果只想为某些路由添加中间件，可以在路由或路由组上使用 Use()。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 Gin 路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由组，只有该组下的路由才会使用该中间件</span></span><br><span class="line">api := r.Group(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">api.Use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;API request&quot;</span>)</span><br><span class="line">c.Next() <span class="comment">// 调用下一个中间件或处理函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由</span></span><br><span class="line">api.GET(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;User list&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习来源&lt;a href=&quot;https://geektutu.com/post/quick-go-gin.html&quot;&gt;极客兔兔Gin简明教程&lt;</summary>
      
    
    
    
    <category term="Go学习" scheme="http://example.com/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
    <category term="Gin" scheme="http://example.com/tags/Gin/"/>
    
    <category term="后端" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>go-net/http标准库简明教程</title>
    <link href="http://example.com/2024/12/02/go-net&amp;http%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/12/02/go-net&amp;http%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</id>
    <published>2024-12-02T09:52:10.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天懒了（bushi），快赶赶进度…<br>学习来源<a href="https://chatgpt.com/">ChatGPT</a>&amp;&amp;<a href="https://gobyexample-cn.github.io/http-clients">Go by example</a><br>本文会包括go的net/http标准库等基础知识！零基础小白请放心使用!<br>会有涉及计网的一点知识 <del>(本人也正在cs144里挣扎)</del><br><del>好难过下周要考计组和数据结构</del><br>长文预警！！！</p><h1 id="Go的net-http标准库"><a href="#Go的net-http标准库" class="headerlink" title="Go的net/http标准库"></a>Go的net/http标准库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>net/http 是什么<br>它是 Go 标准库中用来处理 HTTP 请求和响应的模块，提供了构建 Web 服务的基本功能。  </li><li>核心组件  <ul><li>http.Server：表示 HTTP 服务器。  </li><li>http.Request：表示 HTTP 请求。  </li><li>http.ResponseWriter：用于构造 HTTP 响应。  </li><li>路由与处理器：通过 Handler 接口和 ServeMux 路由器来实现。  </li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, %s!&quot;</span>, r.URL.Path[<span class="number">1</span>:]) <span class="comment">// 响应内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler) <span class="comment">// 注册处理函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Server is running on http://localhost:8080&quot;</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 启动服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，访问 <a href="http://localhost:8080/Go，浏览器将显示：Hello">http://localhost:8080/Go，浏览器将显示：Hello</a>, Go!</p><h2 id="分块详细解释"><a href="#分块详细解释" class="headerlink" title="分块详细解释"></a>分块详细解释</h2><h3 id="启动HTTP服务器"><a href="#启动HTTP服务器" class="headerlink" title="启动HTTP服务器"></a>启动HTTP服务器</h3><p><code>http.ListenAndServe</code>  </p><p>用于启动HTTP服务器  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 参数：  </span></span><br><span class="line"><span class="string">  - :8080：监听的端口。  </span></span><br><span class="line"><span class="string">  - nil：表示使用默认的路由器（http.DefaultServeMux）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 自定义`</span><span class="string">`http.Server`</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 Go 的 net/http 标准库中，http.Server 是一个结构体，它表示一个 HTTP 服务器。相比直接使用 http.ListenAndServe，通过自定义 http.Server，可以对服务器的行为进行更细粒度的控制，比如设置超时时间、TLS 配置、监听地址等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### `</span><span class="string">`http.Server`</span><span class="string">`的结构</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr              <span class="type">string</span>           <span class="comment">// 监听地址（如 &quot;:8080&quot;）</span></span><br><span class="line">Handler           http.Handler     <span class="comment">// 请求处理器，默认是 http.DefaultServeMux</span></span><br><span class="line">ReadTimeout       time.Duration    <span class="comment">// 读取请求头的最大时间</span></span><br><span class="line">WriteTimeout      time.Duration    <span class="comment">// 写入响应的最大时间</span></span><br><span class="line">IdleTimeout       time.Duration    <span class="comment">// 连接空闲时间（HTTP/1.1 的 Keep-Alive）</span></span><br><span class="line">MaxHeaderBytes    <span class="type">int</span>              <span class="comment">// 请求头的最大字节数</span></span><br><span class="line">TLSConfig         *tls.Config      <span class="comment">// TLS 配置（用于 HTTPS）</span></span><br><span class="line">ConnState         <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span> <span class="comment">// 连接状态回调</span></span><br><span class="line">ErrorLog          *log.Logger      <span class="comment">// 自定义错误日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求处理器-Handler"><a href="#请求处理器-Handler" class="headerlink" title="请求处理器(Handler)"></a>请求处理器(Handler)</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>Handler 是 Go 中处理 HTTP 请求的一个接口，它定义了以下方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ResponseWriter：<br>用于构建和发送 HTTP 响应。<br>通过它可以设置状态码、响应头以及响应体。  </li><li>Request：<br>表示客户端的 HTTP 请求。<br>包含请求方法、URL、头信息、表单数据等。  </li></ul><p>总结：Handler 是处理 HTTP 请求并返回 HTTP 响应的逻辑核心。</p><h4 id="实现Handler的两种方式"><a href="#实现Handler的两种方式" class="headerlink" title="实现Handler的两种方式"></a>实现Handler的两种方式</h4><h5 id="1-实现http-Handler接口"><a href="#1-实现http-Handler接口" class="headerlink" title="(1)实现http.Handler接口"></a>(1)实现<code>http.Handler</code>接口</h5><p>任何实现了<code>ServeHTTP(w http.ResponseWriter, r *http.Request)</code>方法的类型都可以作为一个 Handler。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line"><span class="comment">//h *myHandler是一个指针接收者，表示ServeHTTP 方法与 myHandler 类型的指针绑定</span></span><br><span class="line"><span class="comment">//http.ResponseWriter 是一个接口，用于构造并发送 HTTP 响应给客户端</span></span><br><span class="line"><span class="comment">//*http.Request 是一个指向请求对象的指针,封装了客户端发来的 HTTP 请求的全部信息</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, you&#x27;ve hit %s\n&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="comment">//r.URL 是标准库 net/url 定义的 url.URL 结构体，用来解析和存储 URL 的详细信息。</span></span><br><span class="line"><span class="comment">//fmt.Fprintf 是 Go 语言中的一个非常常用的函数，它属于 fmt 包</span></span><br><span class="line"><span class="comment">//用于将格式化的字符串输出到指定的 io.Writer 接口对象中，而不是直接输出到控制台。</span></span><br><span class="line"><span class="comment">//与 fmt.Printf 和 fmt.Println 等标准输出函数不同，fmt.Fprintf 可以将输出定向到文件、网络连接、HTTP 响应等任何实现了 io.Writer 接口的对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := &amp;myHandler&#123;&#125;</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, handler)</span><br><span class="line"><span class="comment">//func ListenAndServe(addr string, handler http.Handler) error</span></span><br><span class="line"><span class="comment">//addr string指定服务器的监听地址，包括 IP 和端口号。</span></span><br><span class="line"><span class="comment">//handler http.Handler处理 HTTP 请求的对象，通常是一个实现了 http.Handler 接口的实例。</span></span><br><span class="line"><span class="comment">//启动一个HTTP服务端，持续监听8080端口，直到收到客户端请求</span></span><br><span class="line"><span class="comment">//如果没有指定 IP 地址或域名，那么访问的默认是本机</span></span><br><span class="line">    <span class="comment">//当浏览器发起请求（通过 TCP 协议连接到 localhost:8080）时，服务器接收这个连接</span></span><br><span class="line">    <span class="comment">//解析收到的 HTTP 请求，将请求分发给注册的处理器 handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在terminal中键入<code>go run main.go</code>，然后在浏览器中键入<code>http://localhost:8080/hello</code>,得到<code>Hello, you&#39;ve hit /hello</code></p><p>这个过程中，浏览器相当于客户端，浏览器通过url(<a href="http://localhost:8080/hello)构造出http请求，然后通过DNS解析把域名换算成ip地址，这样客户端知道目标服务器是谁，然后建立tcp/ip连接，再把构造出的http请求发送到目标服务器，在这里也就是把请求发送到本机的8080端口。Go程序相当于服务端，收到并解析http请求，把请求分发给注册的处理器handler。">http://localhost:8080/hello)构造出http请求，然后通过DNS解析把域名换算成ip地址，这样客户端知道目标服务器是谁，然后建立tcp/ip连接，再把构造出的http请求发送到目标服务器，在这里也就是把请求发送到本机的8080端口。Go程序相当于服务端，收到并解析http请求，把请求分发给注册的处理器handler。</a>  </p><p>在 Go 中，http 包提供了一个非常核心的功能：通过 HTTP 路由将不同的请求（通常是 HTTP 方法和路径的组合）指向特定的处理器（Handler）。这个过程叫做 注册。</p><h5 id="2-使用-http-HandlerFunc"><a href="#2-使用-http-HandlerFunc" class="headerlink" title="(2)使用 http.HandlerFunc"></a>(2)使用 <code>http.HandlerFunc</code></h5><p>Go 提供了一个便利的方法，可以将普通函数直接用作 Handler。这是通过类型 http.HandlerFunc 实现的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, you&#x27;ve hit %s\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, myHandler) <span class="comment">// 直接注册处理函数</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/test</code>将返回<code>Hello, you&#39;ve hit /test</code></p><p>如何实现的？<br>http.HandleFunc 的底层实现会将你传递的函数（如 myHandler）转为一个匿名的结构体，并为这个结构体实现 ServeHTTP 方法。这个匿名结构体的 ServeHTTP 方法就是你提供的 myHandler 函数。可以理解为 http.HandleFunc 自动为你完成了接口的实现。</p><h3 id="HTTP-请求对象-http-Request"><a href="#HTTP-请求对象-http-Request" class="headerlink" title="HTTP 请求对象 (http.Request)"></a>HTTP 请求对象 (http.Request)</h3><p>http.Request 是 Go 中处理 HTTP 请求的核心结构体，包含了许多关于请求的详细信息，包括请求方法、URL、头部、请求体等。通过这个结构体，你可以访问并处理各种与 HTTP 请求相关的数据，进而实现 HTTP 服务的功能。  </p><p>在本地显示读取控制。</p><h4 id="http-Request的主要字段（仅举例两个）"><a href="#http-Request的主要字段（仅举例两个）" class="headerlink" title="http.Request的主要字段（仅举例两个）"></a><code>http.Request</code>的主要字段（仅举例两个）</h4><ol><li><p><code>Method</code>（请求方法）</p><ul><li>类型：string</li><li>描述：表示 HTTP 请求的类型，如 GET、POST、PUT、DELETE 等。</li><li>例如，如果是一个 GET 请求，Method 会是 “GET”，如果是一个 POST 请求，Method 会是 “POST”。</li><li>例子：r.Method 可以帮助你判断请求的类型。</li></ul></li><li><p><code>URL</code>（请求的URL）</p><ul><li>类型：*url.URL</li><li>描述：表示客户端请求的 URL 地址。这个字段是一个指向 url.URL 结构体的指针，包含了完整的 URL 信息。</li><li>通过 r.URL.Path，你可以获取请求的路径（例如 /hello）。而 r.URL.Query() 可以用于获取 URL 查询参数（如 ?name=John）。</li><li>例子：<ul><li>r.URL.Path：/hello 代表访问路径。</li><li>r.URL.RawQuery：查询字符串部分，例如 name=John&amp;age=30。</li></ul></li></ul></li></ol><h3 id="HTTP-响应对象-http-ResponseWriter"><a href="#HTTP-响应对象-http-ResponseWriter" class="headerlink" title="HTTP 响应对象 (http.ResponseWriter)"></a>HTTP 响应对象 (http.ResponseWriter)</h3><p>示例代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line"><span class="comment">// 设置响应状态码为 201 Created</span></span><br><span class="line">w.WriteHeader(http.StatusCreated)</span><br><span class="line"><span class="comment">// 写入响应体内容</span></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, client!&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器，监听端口 8080</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h4><p>代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br></pre></td></tr></table></figure></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><strong>响应头（HTTP Headers）</strong>是服务器向客户端提供的关于响应的元信息。</li><li>Content-Type 是一个常用的响应头，它告诉客户端响应体的内容类型和格式，帮助客户端正确解析和处理数据。</li><li><p>告知客户端数据类型：<br>客户端需要知道返回的数据是什么类型，以便正确解析。例如：  </p><ul><li>text/plain：表示纯文本。</li><li>text/html：表示 HTML 文档。</li><li>application/json：表示 JSON 数据。  </li></ul><p>如果没有正确设置，客户端可能会错误地解析或显示数据。</p></li><li><p>支持不同的客户端  </p><ul><li>浏览器、移动设备、API 客户端等都依赖 Content-Type 来决定如何处理服务器返回的数据。</li><li>例如，Content-Type: text/html 会让浏览器将响应当作网页渲染，而 Content-Type: application/json 会让 API 客户端将其解析为 JSON 对象。</li></ul></li></ul><h4 id="设置响应状态码"><a href="#设置响应状态码" class="headerlink" title="设置响应状态码"></a>设置响应状态码</h4><p>代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.WriteHeader(http.StatusCreated)</span><br></pre></td></tr></table></figure><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><blockquote><p>状态码的作用是面向客户端的  </p></blockquote><ul><li><p>客户端通过状态码判断请求结果</p><ul><li>状态码如 200 OK 表示请求成功。</li><li>状态码如 404 Not Found 表示客户端请求的资源不存在。</li><li>状态码如 500 Internal Server Error 表示服务器内部出了问题。</li></ul></li><li><p>客户端行为会依赖状态码</p><ul><li>浏览器看到 301 Moved Permanently 会自动重定向到新的 URL。</li><li>API 客户端根据 401 Unauthorized 提示用户需要登录。</li><li>搜索引擎看到 503 Service Unavailable 会知道服务器暂时不可用，稍后再尝试抓取页面。</li></ul></li></ul><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>HTTP 客户端主要用于发送 HTTP 请求到指定的服务器，并接收服务器的响应。net/http 提供了一些简单易用的函数和类型，例如 http.Get、http.Post、http.Client 等。</p><h4 id="核心类型-amp-函数"><a href="#核心类型-amp-函数" class="headerlink" title="核心类型&amp;函数"></a>核心类型&amp;函数</h4><p>(1) http.Client<br>http.Client 是一个可配置的 HTTP 客户端，用于发送请求和接收响应。<br>默认客户端是 http.DefaultClient。<br>(2) http.Request<br>表示一个 HTTP 请求，包含请求方法、URL、头部、请求体等。<br>(3) http.Response<br>表示一个 HTTP 响应，包含状态码、头部、响应体等。<br>(4) 快捷方法  </p><ul><li>http.Get：发送简单的 GET 请求。</li><li>http.Post：发送简单的 POST 请求。</li><li>http.Head、http.PostForm 等：发送其他类型的请求。</li></ul><p><del>懒得写例子直接解释gobyexample里的</del></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span><span class="comment">//提供缓冲I/O操作</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://gobyexample.com&quot;</span>)</span><br><span class="line"><span class="comment">//发送一个http.Get到http://gobyexample.com</span></span><br><span class="line"><span class="comment">//返回响应对象http.Response和error</span></span><br><span class="line"><span class="comment">//resp是一个响应对象，包含状态码，头部和响应体</span></span><br><span class="line"><span class="comment">//err表示是否出错，如果不为nil则代表出错</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line"><span class="comment">//若出错，则终止程序，输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"><span class="comment">//保证在resp.Body使用完后立即关闭</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response status:&quot;</span>, resp.Status)<span class="comment">//打印状态码</span></span><br><span class="line"></span><br><span class="line">    scanner := bufio.NewScanner(resp.Body)</span><br><span class="line"><span class="comment">//创造扫描器，逐行读取响应体中的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; scanner.Scan() &amp;&amp; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">//按行读取响应体，若有下一行则返回true</span></span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描是否有错误，有错误用panic抛出</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP服务端"><a href="#HTTP服务端" class="headerlink" title="HTTP服务端"></a>HTTP服务端</h3><p>HTTP 服务端用于处理客户端的 HTTP 请求并返回响应。Go 提供了一个高效的 HTTP 服务器实现，支持路由处理和并发。</p><h4 id="核心类型-amp-函数-1"><a href="#核心类型-amp-函数-1" class="headerlink" title="核心类型&amp;函数"></a>核心类型&amp;函数</h4><p>(1) http.Handler<br>接口，表示 HTTP 请求的处理器。<br>需要实现 ServeHTTP(w http.ResponseWriter, r *http.Request) 方法。<br>(2) http.Server<br>表示一个 HTTP 服务器，包含监听地址、处理器和其他配置。<br>默认服务器是通过 http.ListenAndServe 启动的。<br>(3) http.ServeMux<br>默认的路由器，负责将请求分发给对应的 Handler。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;hello\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headers</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, headers := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">        <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;%v: %v\n&quot;</span>, name, h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/headers&quot;</span>, headers)</span><br><span class="line"><span class="comment">//注册了两个处理器</span></span><br><span class="line"><span class="comment">//一个打印hello，一个打印所有请求头</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这两天懒了（bushi），快赶赶进度…&lt;br&gt;学习来源&lt;a href=&quot;https://chatgpt.com/&quot;&gt;ChatGPT&lt;/a&gt;&amp;</summary>
      
    
    
    
    <category term="Go学习" scheme="http://example.com/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-单元测试</title>
    <link href="http://example.com/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2024-11-26T09:21:04.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>零基础小白可放心食用！有很多概念解释比如匹配or通配符等等，一起加油！</p></blockquote><p>学习来源：  </p><ul><li><a href="https://geektutu.com/post/quick-go-test.html">极客兔兔-Go Test单元测试简明教程</a></li><li><a href="https://chatgpt.com/">ChatGPT</a></li></ul><p>Go 的单元测试是 Go 语言中内置的一个重要功能，支持开发者快速验证代码的正确性。通过标准库 testing 和相关工具（如 go test），你可以编写简洁、高效的单元测试用例。</p><h1 id="单元测试基本概念"><a href="#单元测试基本概念" class="headerlink" title="单元测试基本概念"></a>单元测试基本概念</h1><ul><li>单元测试是指对代码中最小的可测试部分（如函数或方法）进行验证，以确保其行为符合预期。  </li><li>在 Go 中，单元测试文件以 _test.go 为后缀，测试函数以 Test 开头。  </li><li>Go 的测试框架是内置的，运行 go test 命令即可执行测试。  </li></ul><h1 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h1><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example/</span><br><span class="line">    |--calc.go</span><br><span class="line">    |--calc_test.go</span><br></pre></td></tr></table></figure><br>例如calc.go代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func Add(a int, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Mul(a int, b int) int &#123;</span><br><span class="line">    return a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则在同一个包中的calc_test.go可以这么写<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">if ans := Add(1, 2); ans != 3 &#123;</span><br><span class="line">t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ans := Add(-10, -20); ans != -30 &#123;</span><br><span class="line">t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>文件名必须以 _test.go 结尾。</li><li>测试函数：<ul><li>名称必须以 Test 开头，例如 TestAdd。</li><li>参数为 *testing.T 类型，用于报告测试失败和日志。</li></ul></li><li>测试文件和函数需要在同一个包中。</li></ul><blockquote><p><em>*testing.T 是用于单元测试的参数类型，表示测试上下文。它提供了一系列方法，用于报告测试状态、记录日志、跳过测试等。</em>  </p><p><strong>testing.B 是基准测试的参数类型，表示基准测试上下文。基准测试用于衡量代码的性能，通过* </strong>testing.B 提供的方法控制基准测试的运行。*</p><p><em>*testing.M 是 TestMain 函数的参数类型，用于控制测试的整个生命周期。TestMain 是所有测试的入口点，可以在运行测试前后进行全局的初始化和清理工作。</em>    </p></blockquote><p>运行go test，改package下所有测试都会被运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">ok      example 0.009s</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">或 go <span class="built_in">test</span> -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   TestMul</span><br><span class="line">--- PASS: TestMul (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>覆盖率</strong><br>衡量测试用例对代码检查程度的指标，表示被测试的代码中实际被执行的部分占整个代码的比例。Go 提供了内置工具来分析测试覆盖率，通过 -cover 参数可以快速查看。<br>覆盖率通常以百分比表示，用来评估测试的有效性。测试覆盖率有以下几种类型：  </p><ul><li>语句覆盖率（Statement Coverage）：被执行的代码语句占总语句数的比例。</li><li>分支覆盖率（Branch Coverage）：被测试的代码中，分支条件（如 if 和 else）被覆盖的比例。</li><li>函数覆盖率（Function Coverage）：被调用的函数占总函数数的比例。  </li></ul><p>在 Go 中，-cover 参数默认显示语句覆盖率。  </p><p>如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run TestAdd -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>匹配，通配符与正则表达式</strong></p><ul><li>匹配：在 Go 的单元测试中，-run 参数用于指定运行哪些测试用例，通过匹配测试函数的名称来决定哪些测试会被执行。具体来说，根据你提供的通配符或正则表达式，与测试函数的名字进行对比。如果函数的名字符合你给定的模式，那么该测试用例会被运行。  </li><li><p>匹配的种类：</p><ul><li><p>运行指定测试<br>运行TestAdd<code>go test -run=TestAdd</code>  </p></li><li><p>使用通配符  </p><ul><li>运行所有以Test开头的测试<code>go test -run=Test*</code></li></ul></li><li><p>使用正则表达式<br>运行以 Test 开头且包含 Add 或 Subtract 的测试函数<code>go test -run=^Test(Add|Subtract)$</code></p></li></ul></li></ul><h1 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h1><p>在 Go 中，子测试是一种强大的功能，可以在一个测试函数中组织和运行多个相关的子测试。通过使用子测试，你可以对一组逻辑相关的测试进行分组，并更清晰地描述每个测试的意图。这种功能通常用在参数化测试或者复杂场景的分层测试中。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>子测试是通过 t.Run(name, func(t *testing.T)) 创建的：  </p><ul><li>name：为子测试指定一个描述性名称，用于标识这个测试。</li><li>匿名函数 func(t *testing.T)：定义子测试的逻辑。</li><li>子测试会在父测试中运行，可以嵌套多层，形成类似层级结构的测试组织方式。</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被测试函数,应该在同源的另一个文件里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">//结构体切片tests，定义了一组测试输入和期望输出</span></span><br><span class="line">        </span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">a, b     <span class="type">int</span></span><br><span class="line">expected <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">        <span class="comment">//子测试的名字会出现，更容易定位错误</span></span><br><span class="line">&#123;<span class="string">&quot;Add positives&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add negatives&quot;</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add mixed&quot;</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历测试用例并运行子测试</span></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="comment">//匿名函数，内联在t.Run中</span></span><br><span class="line">            <span class="comment">//每个子测试调用时，匿名函数被立即执行</span></span><br><span class="line"><span class="comment">//匿名函数内部代码定义了子测试的具体行为</span></span><br><span class="line">            result := Add(tt.a, tt.b)</span><br><span class="line"><span class="keyword">if</span> result != tt.expected &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Add(%d, %d) = %d; want %d&quot;</span>, tt.a, tt.b, result, tt.expected)</span><br><span class="line">                <span class="comment">//t.Errorf 用于记录一条格式化的错误信息，同时标记当前测试失败。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行<code>go test -v</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">=== RUN   TestAdd/Addnec</span><br><span class="line">=== RUN   TestAdd/Addpos</span><br><span class="line">=== RUN   TestAdd/Addmix</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addnec (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addpos (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addmix (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      go-practice     0.360s</span><br></pre></td></tr></table></figure><h3 id="嵌套子测试"><a href="#嵌套子测试" class="headerlink" title="嵌套子测试"></a>嵌套子测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func TestMath(t *testing.T) &#123;</span><br><span class="line">// 一级子测试</span><br><span class="line">t.Run(&quot;Addition&quot;, func(t *testing.T) &#123;</span><br><span class="line">if Add(1, 2) != 3 &#123;</span><br><span class="line">t.Error(&quot;Addition failed&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 二级子测试</span><br><span class="line">t.Run(&quot;Multiplication&quot;, func(t *testing.T) &#123;</span><br><span class="line">t.Run(&quot;Positive numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if 2*3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for positive numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">t.Run(&quot;Negative numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if -2*-3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for negative numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="帮助函数"><a href="#帮助函数" class="headerlink" title="帮助函数"></a>帮助函数</h1><p>Go 的 testing 包提供了一个特殊的函数 t.Helper()，可以用来标记一个函数是测试的帮助函数，从而在测试失败时，错误信息中忽略这个帮助函数的调用栈，直接指向调用帮助函数的实际测试函数。</p><p><strong>无帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    if result := Add(2, 3); result != 5 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(2, 3) = %d; want 5&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(0, 0); result != 0 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(0, 0) = %d; want 0&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(-1, -1); result != -2 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(-1, -1) = %d; want -2&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>含有帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func checkAdd(t *testing.T, a, b, expected int) &#123;</span><br><span class="line">    t.Helper() // 标记为帮助函数</span><br><span class="line">    if result := Add(a, b); result != expected &#123;</span><br><span class="line">        t.Errorf(&quot;Add(%d, %d) = %d; want %d&quot;, a, b, result, expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    //复用，更简洁高效</span><br><span class="line">    checkAdd(t, 2, 3, 5)</span><br><span class="line">    checkAdd(t, 0, 0, 0)</span><br><span class="line">    checkAdd(t, -1, -1, -2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="setup和teardown"><a href="#setup和teardown" class="headerlink" title="setup和teardown"></a>setup和teardown</h1><p>在 Go 的测试中，Setup 和 Teardown 是两个常见的概念，用于在测试开始之前执行初始化工作（Setup），以及在测试结束之后进行清理工作（Teardown）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func setup() &#123;</span><br><span class="line">fmt.Println(&quot;Before all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func teardown() &#123;</span><br><span class="line">fmt.Println(&quot;After all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test1(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test2(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestMain(m *testing.M) &#123;</span><br><span class="line">setup()</span><br><span class="line">code := m.Run()</span><br><span class="line">teardown()</span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>集中控制测试环境：<br>TestMain 允许在单个位置控制测试的初始化和清理逻辑，而无需在每个测试中手动处理。</li><li>确保环境一致性：<br>使用 setup 和 teardown 可以确保所有测试运行在一个受控的环境中，避免因测试环境问题导致的不一致结果。</li><li>可扩展性：<br>如果需要增加更多的全局操作（如日志记录或配置加载），可以很方便地在 setup 和 teardown 中添加。</li></ul><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>Go 中的基准测试（Benchmarking）用于评估代码的性能，帮助开发者了解程序在执行时的效率和优化空间。与常规的单元测试不同，基准测试主要关注执行时间和性能瓶颈的定位，通过 testing 包中的 testing.B 类型来实现。testing.B 提供了一些方法和属性，可以用于测量函数的执行时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 被测试的函数</span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基准测试函数</span><br><span class="line">func BenchmarkAdd(b *testing.B) &#123;</span><br><span class="line">// 基准测试循环</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BenchmarkAdd 是基准测试函数。基准测试函数必须以 Benchmark 开头，并接收一个 *testing.B 类型的参数。</li><li>b.N 是基准测试的循环次数。testing.B 会根据需要调整这个值，以确保测试的执行时间足够长，能准确地测量性能。</li><li>b.N 会自动增长，确保函数执行足够多次，以消除偶然的波动。</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\code2024\go<span class="literal">-practice</span>&gt; go test <span class="literal">-bench</span> .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go<span class="literal">-practice</span></span><br><span class="line">cpu: Intel(<span class="built_in">R</span>) Core(TM) i7<span class="literal">-1065G7</span> CPU <span class="selector-tag">@</span> <span class="number">1.30</span>GHz</span><br><span class="line">Benchmark<span class="built_in">Add-8</span>          <span class="number">1000000000</span>               <span class="number">0.3078</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go<span class="literal">-practice</span>     <span class="number">0.829</span>s</span><br></pre></td></tr></table></figure><p>如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkHello(b *testing.B) &#123;</span><br><span class="line">    ... // 耗时操作</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;零基础小白可放心食用！有很多概念解释比如匹配or通配符等等，一起加油！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Go学习" scheme="http://example.com/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-并发编程</title>
    <link href="http://example.com/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-11-25T21:22:15.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前从未接触过并发编程的童鞋可放心食用！  </p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><ul><li>并发 (Concurrency)：<br>并发是指同时处理多个任务的能力，但这些任务不一定是同时执行的。任务可能通过切换来共享时间片。  </li><li>并行 (Parallelism)：<br>并行是指多个任务同时执行，需要多个处理器核心支持。在 Go 中，Goroutine 是通过调度器来实现并发，最终通过 CPU 核心实现并行。</li></ul><p>并发和并行的关系：<br>并发是逻辑上的任务切换，而并行是物理上的任务同时运行。</p><h1 id="Go的并发核心：Goroutine"><a href="#Go的并发核心：Goroutine" class="headerlink" title="Go的并发核心：Goroutine"></a>Go的并发核心：Goroutine</h1><h2 id="Goroutine是什么"><a href="#Goroutine是什么" class="headerlink" title="Goroutine是什么"></a>Goroutine是什么</h2><p>Goroutine 是 Go 的协程实现，是一种比传统线程更轻量级的并发任务单元。</p><ul><li>轻量：一个 Goroutine 启动时仅占用大约 2 KB 的内存（相比线程，通常占用 1 MB 堆栈）。  </li><li>调度灵活：由 Go 的运行时（runtime）管理调度，而不是直接依赖操作系统内核线程。  </li><li>高效：Go 的运行时会动态调整 Goroutine 的栈大小（最小 2 KB，最大可达 1 GB），并通过用户态线程池实现调度。  </li></ul><p>协程 vs 线程：  </p><ul><li>线程：由操作系统调度，重量级，开销较大（如栈内存固定且较大、上下文切换代价高）。  </li><li>协程：由语言运行时调度，轻量级，开销小（动态栈、用户态上下文切换）。</li></ul><h2 id="创建和使用-Goroutine"><a href="#创建和使用-Goroutine" class="headerlink" title="创建和使用 Goroutine"></a>创建和使用 Goroutine</h2><p>创建一个 Goroutine 的方法非常简单，使用 go 关键字即可。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Task is running&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> task() <span class="comment">// 启动一个 Goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Main function&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 确保主 Goroutine 不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>运行结果（顺序不可预测，Task is running可能都不会输出）：</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main function</span><br><span class="line">Task is running</span><br></pre></td></tr></table></figure><ul><li>go task()：启动一个新的 Goroutine，运行 task 函数。</li><li>主 Goroutine 继续执行 fmt.Println(“Main function”)。</li><li>如果没有 time.Sleep，主 Goroutine 会立即退出，程序结束，task 可能尚未完成。 </li></ul><h2 id="Goroutine的生命周期"><a href="#Goroutine的生命周期" class="headerlink" title="Goroutine的生命周期"></a>Goroutine的生命周期</h2><p>(1) 启动 Goroutine  </p><ul><li>Goroutine 是通过 go 关键字启动的。</li><li>每个 Goroutine 都会独立执行其任务，但与其他 Goroutine 和主 Goroutine 共享相同的地址空间。  </li></ul><p>(2) 运行中</p><ul><li>Goroutine 的调度由 Go 运行时管理，运行时会将多个 Goroutine 映射到少量的系统线程（M:N 模型）。</li><li>Goroutine 的执行顺序不确定，由运行时的调度算法决定。  </li></ul><p>(3) 结束</p><ul><li>Goroutine 执行完成或返回时会自动退出，无需显式销毁。</li></ul><h1 id="Goroutine-之间的同步与通信工具"><a href="#Goroutine-之间的同步与通信工具" class="headerlink" title="Goroutine 之间的同步与通信工具"></a>Goroutine 之间的同步与通信工具</h1><h2 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h2><p>sync 提供了一组基础的同步原语，用于解决 Goroutine 之间的同步问题，确保共享数据在多 Goroutine 环境下安全访问。</p><h3 id="常见的-sync-工具"><a href="#常见的-sync-工具" class="headerlink" title="常见的 sync 工具"></a>常见的 sync 工具</h3><p> <em>(1) sync.WaitGroup</em><br> 作用：等待一组 Goroutine 完成。<br> WaitGroup 提供了三个方法：</p><ul><li>Add(delta int)：设置需要等待的 Goroutine 数量（+delta）。</li><li>Done()：每当一个 Goroutine 完成任务，调用一次，表示减少一个需要等待的任务（-1）。</li><li>Wait()：阻塞主 Goroutine，直到所有计数归零。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// 减少计数</span></span><br><span class="line">    <span class="comment">//defer保证这句话总是在worker函数结束的时候执行，控制进程减1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line"><span class="comment">// 模拟工作任务</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数</span></span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 阻塞，直到所有任务完成</span></span><br><span class="line">fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>注：Goroutines 是按照 for 循环的顺序启动的（1, 2, 3）。这意味着 Goroutines 被创建时的顺序是确定的。实际执行顺序取决于 Go 运行时调度器，调度器会决定哪个 Goroutine 先运行。</em></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Channel 是 Go 语言中用于 在 Goroutines 之间传递数据的核心机制之一。它是 Go 中并发编程的一个重要特性，可以让不同的 Goroutines 安全地通信和同步。Channel 是一种类型化的管道，可以用于在多个 Goroutines 之间传递消息，且无需使用锁（mutex）来保证同步。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><em>声明与初始化</em>：<br>使用 make 函数创建一个 channel，并可以指定容量（缓冲区大小）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Type是通道的数据类型</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Type  <span class="comment">// 声明一个空的 channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 创建一个 channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 声明并初始化一个 channel</span></span><br><span class="line"><span class="comment">//Type 是通过 channel 传递的数据类型，表示你希望在 channel 中传递的数据类型。</span></span><br></pre></td></tr></table></figure><br><em>发送数据&amp;接收数据</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- data  <span class="comment">// 将数据发送到 channel</span></span><br><span class="line">data := &lt;-ch  <span class="comment">// 从 channel 接收数据并赋值给变量</span></span><br></pre></td></tr></table></figure><br><em>关闭 Channel</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)  <span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="comment">//使用 close(ch) 来关闭一个 channel，表示没有更多的数据会发送到该 channel。</span></span><br><span class="line"><span class="comment">//close 主要用于通知接收方，数据传输已经结束，接收方可以在接收数据时检查 channel 是否已关闭。</span></span><br></pre></td></tr></table></figure></p><p><em>通道方向</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通道：传送带</span></span><br><span class="line"><span class="comment">//只读：只能从传送带拿走东西</span></span><br><span class="line"><span class="comment">//只写：只能把东西放到传送带上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onre</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">//只读，读出来</span></span><br><span class="line">Gol := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> Gol == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onwr</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">//只写，写进去</span></span><br><span class="line">ch &lt;- <span class="number">30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅的超时处理"><a href="#优雅的超时处理" class="headerlink" title="优雅的超时处理"></a>优雅的超时处理</h3><p>凭借通道和select可以轻松完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优雅的超时处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-c1:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲区与非缓冲区"><a href="#缓冲区与非缓冲区" class="headerlink" title="缓冲区与非缓冲区"></a>缓冲区与非缓冲区</h3><ul><li>非缓冲 channel：<br>发送方和接收方必须同时准备好，才能完成数据传递。发送方在发送数据时会阻塞，直到有接收方准备好接收数据。  </li><li>缓冲 channel：<br>可以预设一个缓冲区大小，在发送数据时，若缓冲区未满，发送方不会阻塞。只有当缓冲区满时，发送方才会被阻塞。接收方也不会立即阻塞，直到缓冲区为空时</li></ul><p><strong>非缓冲channel示例</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)  <span class="comment">// 创建一个非缓冲 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 Goroutine 发送数据</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;Hello, Go!&quot;</span>  <span class="comment">// 发送数据到 channel</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据并输出</span></span><br><span class="line">    message := &lt;-ch  <span class="comment">// 从 channel 接收数据</span></span><br><span class="line">    fmt.Println(message)  <span class="comment">// 输出接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>主 Goroutine 会阻塞在 message := &lt;-ch 直到接收到来自其他 Goroutine 的数据。</li><li>ch &lt;- “Hello, Go!” 会将数据发送到 channel，并且发送操作会阻塞，直到主 Goroutine 执行完 &lt;-ch 来接收数据。</li></ul><p><strong>缓冲channel示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 2)  // 创建一个缓冲区大小为 2 的 channel</span><br><span class="line"></span><br><span class="line">    // 启动一个 Goroutine 发送数据</span><br><span class="line">    go func() &#123;</span><br><span class="line">        ch &lt;- &quot;Message 1&quot;</span><br><span class="line">        ch &lt;- &quot;Message 2&quot;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // 接收并输出数据</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>创建了一个缓冲区大小为 2 的 channel，因此可以在没有阻塞的情况下向 channel 发送 2 条消息。</li><li>当我们从 channel 中接收数据时，如果缓冲区不为空，就能顺利获取到数据。</li><li>若发送3条消息，则会阻塞，直到缓冲区被释放</li></ul><h3 id="Channel-的同步与-Goroutines-协作"><a href="#Channel-的同步与-Goroutines-协作" class="headerlink" title="Channel 的同步与 Goroutines 协作"></a>Channel 的同步与 Goroutines 协作</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)  <span class="comment">// 模拟任务执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">    ch &lt;- <span class="literal">true</span>  <span class="comment">// 通知任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">3</span>)  <span class="comment">// 创建一个缓冲区大小为 3 的 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i, ch)  <span class="comment">// 启动多个 Goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有 Goroutine 完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        &lt;-ch  <span class="comment">// 从 channel 接收任务完成的信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里使用了一个 缓冲 channel 来通知主 Goroutine 每个子 Goroutine 的任务完成。每个工作 Goroutine 在完成任务后通过 ch &lt;- true 向 channel 发送信号。</li><li>主 Goroutine 在 for 循环中通过 &lt;-ch 等待所有任务的完成，直到接收到所有的完成信号。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前从未接触过并发编程的童鞋可放心食用！  &lt;/p&gt;
&lt;h1 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Go学习" scheme="http://example.com/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-语言</title>
    <link href="http://example.com/2024/11/25/go-%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2024/11/25/go-%E8%AF%AD%E8%A8%80/</id>
    <published>2024-11-25T16:09:19.000Z</published>
    <updated>2025-08-01T08:38:39.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>语言学习来源：</p><ul><li><a href="https://gobyexample-cn.github.io/">go-by-example</a></li><li><a href="https://geektutu.com/post/quick-golang.html">极客兔兔go简明教程</a>  </li></ul><p>原来过语言是看个输入输出直接去做题（但是后面看其实没怎么学跟项目有关的），而且这赶上期末&amp;手上有抓紧的项目，换一种方法。速通一下语言，之前学过一点点go语言皮毛，本文主要记录go在语言方面我觉得有趣不同的地方。ps：下一篇涉及并发编程&amp;单元测试</p><h1 id="string-amp-rune"><a href="#string-amp-rune" class="headerlink" title="string&amp;rune"></a>string&amp;rune</h1><p>字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte（中文一般占3byte），打印时需要用 string 进行类型转换&amp;用printf格式化，否则打印的是编码值。<br>为了更方便地处理字符（尤其是 Unicode 字符），Go 提供了 rune 类型作为字符的抽象，尤其是在处理多字节字符时，例如，字符 汉 是一个 Unicode 字符，在 UTF-8 编码下占用了 3 个字节，但作为 rune 类型，它是一个单独的值，可以直接进行操作。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line">rs := []<span class="type">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, r) </span><br><span class="line">     <span class="comment">// 输出每个字符，分别是 H e l l o ,   世 界 !</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片实际上是一个描述符，包含以下三个部分：  </p><ul><li>指向底层数组的指针：切片的数据存储在底层数组中。  </li><li>长度（length）：切片当前的元素数。  </li><li>容量（capacity）：从切片起始位置到底层数组末尾的最大元素数。  </li></ul><p>多个切片可能共享同一个底层数组，如果需要独立操作，应使用 copy 创建新的切片。如果切片扩容导致底层数组更换，原切片和新切片将不再共享同一数组。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从数组创建</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  <span class="comment">// 数组</span></span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>]                 <span class="comment">// 从数组创建切片，包含索引 1 到 3 的元素</span></span><br><span class="line">fmt.Println(s)                <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)          <span class="comment">// 创建长度为 5 的切片，初始值为零值</span></span><br><span class="line">fmt.Println(s)               <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)      <span class="comment">// 创建长度为 3，容量为 5 的切片</span></span><br><span class="line">fmt.Println(s2)              <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make函数</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//type: 数据结构的类型，必须是 slice、map 或 channel。</span></span><br><span class="line"><span class="comment">//len: 数据结构的长度（对于切片和通道来说是可选参数）。</span></span><br><span class="line"><span class="comment">//cap: 数据结构的容量（仅对切片和带缓冲的通道有效，是可选参数）。</span></span><br><span class="line"><span class="comment">//如果没有显式指定容量，默认容量等于长度：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取长度，容量</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 长度: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 容量: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片  </span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sub := s[<span class="number">1</span>:<span class="number">4</span>]         <span class="comment">// 从索引 1 到索引 3（不包含 4）</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line">sub = s[:<span class="number">3</span>]           <span class="comment">// 从索引 0 到 2</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">sub = s[<span class="number">2</span>:]           <span class="comment">// 从索引 2 到末尾</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [3 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增长</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">// 增加多个元素</span></span><br><span class="line">fmt.Println(s)        <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅声明</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 声明时初始化</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Sam&quot;</span>: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line"><span class="string">&quot;Alice&quot;</span>: <span class="string">&quot;Female&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer-amp-recover"><a href="#defer-amp-recover" class="headerlink" title="defer&amp;recover"></a>defer&amp;recover</h1><p>被 defer 的函数调用会在所在函数返回前（无论是正常返回还是因 panic 提前退出）被执行。<br>函数运行时，先跑别的，然后去找并运行defer函数（<em>被 defer 的函数调用会在所在函数返回前——无论是正常返回还是因 panic 提前退出——被执行。</em>）。在defer函数内部调用recover函数，捕获恢复程序<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(index <span class="type">int</span>)</span></span> (ret <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Some error happened!&quot;</span>, r)</span><br><span class="line">ret = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">return</span> arr[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(get(<span class="number">5</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h2><p><mark>隐式接口实现    </p><p>Go 使用隐式接口实现机制，意思是你不需要显式地声明一个类型实现了某个接口。</p><p>只要一个类型提供了接口所要求的<mark>全部方法（包括方法的名字、参数、返回值类型都一致）</mark>，那么 Go 就会认为这个类型实现了该接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stu.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Person = &amp;Student&#123;</span><br><span class="line">name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(p.getName()) <span class="comment">// Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：  </p><ul><li>定义接口 Person 和两个结构体 Student 和 Worker。  </li><li>实现 getName 方法，使得 <em>Student 和 </em>Worker 都满足 Person 接口。  </li><li>在 main 函数中：<ul><li>创建一个 *Student 的实例。</li><li>将其赋值给 Person 类型变量 p。</li><li>调用 p.getName() 方法，实际执行的是 *Student.getName，返回 Tom。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;语言学习来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gobyexample-cn.github.io/&quot;&gt;go-by</summary>
      
    
    
    
    <category term="Go学习" scheme="http://example.com/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
</feed>
